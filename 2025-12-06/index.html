<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>백준 알고리즘 문제 풀이 모음 (발표용 포함)</title>
    <style>
        body { font-family: 'Noto Sans KR', sans-serif; line-height: 1.6; color: #333; max-width: 1000px; margin: 0 auto; padding: 20px; background-color: #f4f4f9; }
        h1 { text-align: center; color: #2c3e50; margin-bottom: 40px; }
        .problem-container { background: #fff; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); margin-bottom: 40px; padding: 30px; }
        h2 { border-bottom: 2px solid #3498db; padding-bottom: 10px; color: #2980b9; }
        h3 { margin-top: 20px; color: #34495e; font-size: 1.1em; }
        
        /* 공통 설명 박스 */
        .description { background-color: #f9f9f9; padding: 15px; border-left: 4px solid #3498db; margin-bottom: 20px; }
        
        /* 예제 박스 */
        .example-box { display: flex; gap: 20px; margin-bottom: 20px; background: #f0f0f0; padding: 15px; border-radius: 5px; }
        .example-box > div { flex: 1; }
        
        /* 코드 영역 */
        pre { background: #272822; color: #f8f8f2; padding: 15px; border-radius: 5px; overflow-x: auto; font-family: 'Consolas', monospace; font-size: 0.95em; }
        .code-tabs { display: flex; margin-bottom: 0; }
        .tab-button { background-color: #e0e0e0; border: none; padding: 10px 20px; cursor: pointer; font-weight: bold; color: #555; border-radius: 5px 5px 0 0; margin-right: 5px; transition: 0.3s; }
        .tab-button.active { background-color: #272822; color: #fff; }
        .code-content { display: none; background: #272822; padding: 20px; border-radius: 0 5px 5px 5px; }
        .code-content.active { display: block; }
        .io-header { font-weight: bold; margin-bottom: 5px; display: block; }

        /* 5번 문제 전용 스타일 (상세 설명) */
        .logic-box { background-color: #e8f6f3; padding: 20px; border-radius: 5px; margin-bottom: 20px; border: 1px solid #d1f2eb; }
        .dp-table { border-collapse: collapse; width: 100%; text-align: center; margin: 20px 0; font-size: 0.9em; }
        .dp-table th, .dp-table td { border: 1px solid #ddd; padding: 8px; }
        .dp-table th { background-color: #f2f2f2; font-weight: bold; }
        .highlight-match { background-color: #d4edda; color: #155724; font-weight: bold; } /* 매칭 (초록) */
        .highlight-path { background-color: #fff3cd; color: #856404; font-weight: bold; border: 2px solid #ffc107 !important;} /* 역추적 경로 (노랑) */
        .explanation-list li { margin-bottom: 10px; }
    </style>
    <script>
        function openTab(evt, problemId, lang) {
            var i, tabcontent, tablinks;
            var container = document.getElementById(problemId);
            tabcontent = container.getElementsByClassName("code-content");
            for (i = 0; i < tabcontent.length; i++) {
                tabcontent[i].style.display = "none";
                tabcontent[i].classList.remove("active");
            }
            tablinks = container.getElementsByClassName("tab-button");
            for (i = 0; i < tablinks.length; i++) {
                tablinks[i].classList.remove("active");
            }
            container.querySelector(`.code-${lang}`).style.display = "block";
            evt.currentTarget.classList.add("active");
        }
    </script>
</head>
<body>

    <h1>백준 알고리즘 문제 풀이 모음</h1>

    <div id="p1463" class="problem-container">
        <h2>1. 1로 만들기 (1463번)</h2>
        <div class="description">
            정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지이다.<br>
            1. X가 3으로 나누어 떨어지면, 3으로 나눈다.<br>
            2. X가 2로 나누어 떨어지면, 2로 나눈다.<br>
            3. 1을 뺀다.<br>
            정수 N이 주어졌을 때, 위와 같은 연산 세 개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 구하시오.
        </div>
        <div class="example-box">
            <div>
                <span class="io-header">예제 입력</span>
                <pre>10</pre>
            </div>
            <div>
                <span class="io-header">예제 출력</span>
                <pre>3</pre>
            </div>
        </div>
        
        <div class="code-tabs">
            <button class="tab-button active" onclick="openTab(event, 'p1463', 'py')">Python</button>
            <button class="tab-button" onclick="openTab(event, 'p1463', 'java')">Java</button>
            <button class="tab-button" onclick="openTab(event, 'p1463', 'js')">JavaScript</button>
        </div>

        <div class="code-content code-py active">
<pre>import sys
input = sys.stdin.readline

N = int(input())

# 연산 횟수를 저장할 dp 테이블 초기화 (인덱스 N까지 사용)
dp = [0] * (N + 1)

for i in range(2, N + 1):
    # 1. 먼저 1을 뺀 경우의 수를 기본값으로 설정
    dp[i] = dp[i - 1] + 1

    # 2. 2로 나누어 떨어지면, 1을 뺀 값과 비교하여 최솟값 갱신
    if i % 2 == 0:
        dp[i] = min(dp[i], dp[i // 2] + 1)

    # 3. 3으로 나누어 떨어지면, 현재 값과 비교하여 최솟값 갱신
    if i % 3 == 0:
        dp[i] = min(dp[i], dp[i // 3] + 1)

print(dp[N])</pre>
        </div>
        <div class="code-content code-java">
<pre>import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        int[] dp = new int[N + 1];

        for (int i = 2; i <= N; i++) {
            dp[i] = dp[i - 1] + 1;
            if (i % 2 == 0) dp[i] = Math.min(dp[i], dp[i / 2] + 1);
            if (i % 3 == 0) dp[i] = Math.min(dp[i], dp[i / 3] + 1);
        }

        System.out.println(dp[N]);
    }
}</pre>
        </div>
        <div class="code-content code-js">
<pre>const fs = require('fs');
const N = Number(fs.readFileSync('/dev/stdin').toString());

const dp = new Array(N + 1).fill(0);

for (let i = 2; i <= N; i++) {
    dp[i] = dp[i - 1] + 1;
    if (i % 2 === 0) dp[i] = Math.min(dp[i], dp[i / 2] + 1);
    if (i % 3 === 0) dp[i] = Math.min(dp[i], dp[i / 3] + 1);
}

console.log(dp[N]);</pre>
        </div>
    </div>

    <div id="p14501" class="problem-container">
        <h2>2. 퇴사 (14501번)</h2>
        <div class="description">
            오늘부터 N+1일째 되는 날 퇴사를 하기 위해서, 남은 N일 동안 최대한 많은 상담을 하려고 한다.<br>
            각각의 상담은 상담을 완료하는데 걸리는 기간 Ti와 상담을 했을 때 받을 수 있는 금액 Pi로 이루어져 있다.<br>
            상담을 적절히 했을 때, 백준이가 얻을 수 있는 최대 수익을 구하는 프로그램을 작성하시오.
        </div>
        <div class="example-box">
            <div>
                <span class="io-header">예제 입력</span>
                <pre>7
3 10
5 20
1 10
1 20
2 15
4 40
2 200</pre>
            </div>
            <div>
                <span class="io-header">예제 출력</span>
                <pre>45</pre>
            </div>
        </div>

        <div class="code-tabs">
            <button class="tab-button active" onclick="openTab(event, 'p14501', 'py')">Python</button>
            <button class="tab-button" onclick="openTab(event, 'p14501', 'java')">Java</button>
            <button class="tab-button" onclick="openTab(event, 'p14501', 'js')">JavaScript</button>
        </div>

        <div class="code-content code-py active">
<pre>import sys
input = sys.stdin.readline

N = int(input())
schedule = [list(map(int, input().split())) for _ in range(N)]

dp = [0] * (N + 1)

for i in range(N - 1, -1, -1):
    time, pay = schedule[i]

    if i + time > N:
        dp[i] = dp[i + 1]
    else:
        dp[i] = max(dp[i + 1], pay + dp[i + time])

print(dp[0])</pre>
        </div>
        <div class="code-content code-java">
<pre>import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        int[] T = new int[N];
        int[] P = new int[N];
        
        for(int i=0; i<N; i++) {
            T[i] = sc.nextInt();
            P[i] = sc.nextInt();
        }
        
        int[] dp = new int[N + 1];
        
        for (int i = N - 1; i >= 0; i--) {
            if (i + T[i] > N) {
                dp[i] = dp[i + 1];
            } else {
                dp[i] = Math.max(dp[i + 1], P[i] + dp[i + T[i]]);
            }
        }
        
        System.out.println(dp[0]);
    }
}</pre>
        </div>
        <div class="code-content code-js">
<pre>const fs = require('fs');
const input = fs.readFileSync('/dev/stdin').toString().trim().split('\n');
const N = Number(input[0]);
const schedule = input.slice(1).map(line => line.split(' ').map(Number));

const dp = new Array(N + 1).fill(0);

for (let i = N - 1; i >= 0; i--) {
    const [time, pay] = schedule[i];
    if (i + time > N) {
        dp[i] = dp[i + 1];
    } else {
        dp[i] = Math.max(dp[i + 1], pay + dp[i + time]);
    }
}

console.log(dp[0]);</pre>
        </div>
    </div>

    <div id="p2193" class="problem-container">
        <h2>3. 이친수 (2193번)</h2>
        <div class="description">
            0과 1로만 이루어진 수를 이진수라 한다. 다음 조건을 만족하는 이진수를 '이친수'라 한다.<br>
            1. 이친수는 0으로 시작하지 않는다.<br>
            2. 이친수에서는 1이 두 번 연속으로 나타나지 않는다. 즉, 11을 부분 문자열로 갖지 않는다.<br>
            N자리 이친수의 개수를 구하는 프로그램을 작성하시오.
        </div>
        <div class="example-box">
            <div>
                <span class="io-header">예제 입력</span>
                <pre>3</pre>
            </div>
            <div>
                <span class="io-header">예제 출력</span>
                <pre>2</pre>
            </div>
        </div>

        <div class="code-tabs">
            <button class="tab-button active" onclick="openTab(event, 'p2193', 'py')">Python</button>
            <button class="tab-button" onclick="openTab(event, 'p2193', 'java')">Java</button>
            <button class="tab-button" onclick="openTab(event, 'p2193', 'js')">JavaScript</button>
        </div>

        <div class="code-content code-py active">
<pre>import sys
input = sys.stdin.readline

N = int(input())

dp = [0] * (N + 1)

dp[1] = 1
if N >= 2:
    dp[2] = 1

for i in range(3, N + 1):
    dp[i] = dp[i - 1] + dp[i - 2]

print(dp[N])</pre>
        </div>
        <div class="code-content code-java">
<pre>import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        long[] dp = new long[N + 1]; // 개수가 많아질 수 있으므로 long 사용

        dp[1] = 1;
        if (N >= 2) dp[2] = 1;

        for (int i = 3; i <= N; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }

        System.out.println(dp[N]);
    }
}</pre>
        </div>
        <div class="code-content code-js">
<pre>const fs = require('fs');
const N = Number(fs.readFileSync('/dev/stdin').toString());

// BigInt 사용 필요 (N=90일 때 값이 큼)
const dp = new Array(N + 1).fill(0n);

if (N >= 1) dp[1] = 1n;
if (N >= 2) dp[2] = 1n;

for (let i = 3; i <= N; i++) {
    dp[i] = dp[i - 1] + dp[i - 2];
}

console.log(dp[N].toString());</pre>
        </div>
    </div>

    <div id="p11726" class="problem-container">
        <h2>4. 2×n 타일링 (11726번)</h2>
        <div class="description">
            2×n 크기의 직사각형을 1×2, 2×1 타일로 채우는 방법의 수를 구하는 프로그램을 작성하시오.<br>
            결과를 10,007로 나눈 나머지를 출력한다.
        </div>
        <div class="example-box">
            <div>
                <span class="io-header">예제 입력</span>
                <pre>9</pre>
            </div>
            <div>
                <span class="io-header">예제 출력</span>
                <pre>55</pre>
            </div>
        </div>
        
        <div class="code-tabs">
            <button class="tab-button active" onclick="openTab(event, 'p11726', 'py')">Python</button>
            <button class="tab-button" onclick="openTab(event, 'p11726', 'java')">Java</button>
            <button class="tab-button" onclick="openTab(event, 'p11726', 'js')">JavaScript</button>
        </div>

        <div class="code-content code-py active">
<pre>import sys
input = sys.stdin.readline

n = int(input())

dp = [0] * 1001

dp[1] = 1
dp[2] = 2

for i in range(3, n + 1):
    dp[i] = (dp[i-1] + dp[i-2]) % 10007

print(dp[n])</pre>
        </div>
        <div class="code-content code-java">
<pre>import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] dp = new int[1001];

        dp[1] = 1;
        dp[2] = 2;

        for (int i = 3; i <= n; i++) {
            dp[i] = (dp[i - 1] + dp[i - 2]) % 10007;
        }

        System.out.println(dp[n]);
    }
}</pre>
        </div>
        <div class="code-content code-js">
<pre>const fs = require('fs');
const n = Number(fs.readFileSync('/dev/stdin').toString());

const dp = new Array(1001).fill(0);
dp[1] = 1;
dp[2] = 2;

for (let i = 3; i <= n; i++) {
    dp[i] = (dp[i - 1] + dp[i - 2]) % 10007;
}

console.log(dp[n]);</pre>
        </div>
    </div>

    <div id="p9252" class="problem-container">
        <h2>5. LCS 2 (9252번) - 상세 분석</h2>
        
        <div class="description">
            <p><strong>LCS (Longest Common Subsequence, 최장 공통 부분 수열)</strong> 문제는 두 수열이 주어졌을 때, 
            두 수열 모두의 부분 수열이 되는 수열 중 가장 긴 것을 찾는 문제입니다.</p>
            <p>주의할 점은 <em>부분 문자열(Substring)</em>과 다르게 문자가 연속될 필요는 없지만, <strong>순서는 지켜져야 합니다.</strong>
            ex: A: HELLO, B: HERO => HEO</p>
        </div>

        <h3>1. 핵심 로직 시각화 (예제 분석)</h3>
        <div class="logic-box">
            <p>두 문자열 <strong>A = "ACAYKP"</strong>와 <strong>B = "CAPCAK"</strong>를 비교해 봅시다.</p>
            <ul class="explanation-list">
                <li><strong>규칙 1 (문자가 같을 때):</strong> 두 문자가 같으면(`A[i] == B[j]`), 왼쪽 위 대각선 값에 +1을 합니다. <br>
                    → 현재 문자를 LCS에 포함시킬 수 있다는 뜻입니다.</li>
                <li><strong>규칙 2 (문자가 다를 때):</strong> 두 문자가 다르면, 왼쪽(`dp[i][j-1]`)이나 위쪽(`dp[i-1][j]`) 중 더 큰 값을 가져옵니다.<br>
                    → 현재 문자가 다르므로, 이전까지 구한 LCS 길이 중 최댓값을 유지합니다.</li>
            </ul>

            <h4>DP 테이블 및 역추적 경로 (노란색이 정답 경로)</h4>
            <table class="dp-table">
                <tr>
                    <th></th> <th>-</th> <th>C</th> <th>A</th> <th>P</th> <th>C</th> <th>A</th> <th>K</th>
                </tr>
                <tr><th>-</th> <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>0</td></tr>
                <tr>
                    <th>A</th> <td>0</td> <td>0</td> <td class="highlight-match">1 (↖)</td> <td>1 (←)</td> <td>1 (←)</td> <td class="highlight-match highlight-path">1 (↖)</td> <td>1 (←)</td>
                </tr>
                <tr>
                    <th>C</th> <td>0</td> <td class="highlight-match highlight-path">1 (↖)</td> <td>1 (↑)</td> <td>1 (←)</td> <td class="highlight-match">2 (↖)</td> <td>2 (←)</td> <td>2 (←)</td>
                </tr>
                <tr>
                    <th>A</th> <td>0</td> <td>1 (↑)</td> <td class="highlight-match highlight-path">2 (↖)</td> <td>2 (←)</td> <td>2 (↑)</td> <td class="highlight-match">3 (↖)</td> <td>3 (←)</td>
                </tr>
                <tr>
                    <th>Y</th> <td>0</td> <td>1 (↑)</td> <td>2 (↑)</td> <td>2 (↑)</td> <td>2 (↑)</td> <td>3 (↑)</td> <td>3 (←)</td>
                </tr>
                <tr>
                    <th>K</th> <td>0</td> <td>1 (↑)</td> <td>2 (↑)</td> <td>2 (↑)</td> <td>2 (↑)</td> <td>3 (↑)</td> <td class="highlight-match highlight-path">4 (↖)</td>
                </tr>
                <tr>
                    <th>P</th> <td>0</td> <td>1 (↑)</td> <td>2 (↑)</td> <td class="highlight-match">3 (↖)</td> <td>3 (↑)</td> <td>3 (↑)</td> <td>4 (↑)</td>
                </tr>
            </table>
            <p><strong>결과 해석:</strong> 우측 하단 끝값 <strong>4</strong>가 LCS의 길이입니다.<br>
            <strong>역추적(Backtracking):</strong> 4에서 시작하여 숫자가 줄어드는(대각선으로 들어온) 지점의 문자를 모으면 <strong>K → A → C → A</strong>가 되고, 이를 뒤집으면 <strong>ACAK</strong>가 됩니다.</p>
        </div>

        <img src="image_973e7f.png" alt="LCS DP Table and Backtracking Path" style="max-width: 100%; border: 1px solid #ddd; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.1);">

        <div class="example-box">
            <div>
                <span class="io-header">예제 입력</span>
                <pre>ACAYKP
CAPCAK</pre>
            </div>
            <div>
                <span class="io-header">예제 출력</span>
                <pre>4
ACAK</pre>
            </div>
        </div>

        <h3>2. 코드 구현 (상세 주석 포함)</h3>
        <div class="code-tabs">
            <button class="tab-button active" onclick="openTab(event, 'p9252', 'py')">Python</button>
            <button class="tab-button" onclick="openTab(event, 'p9252', 'java')">Java</button>
            <button class="tab-button" onclick="openTab(event, 'p9252', 'js')">JavaScript</button>
        </div>

        <div class="code-content code-py active">
<pre>import sys
input = sys.stdin.readline

# 1. 입력 받기 (인덱스 계산을 편하게 하기 위해 앞에 빈 문자열 추가)
A = [""] + list(input().rstrip())
B = [""] + list(input().rstrip())

# 2. DP 테이블 초기화 (문자열 길이 + 1 크기)
# LCS[i][j]: A문자열의 i번째, B문자열의 j번째까지 비교했을 때의 LCS 문자열
# (일반적으로는 길이만 저장하지만, 파이썬은 문자열 연산이 간편하여 직접 저장 가능)
LCS = [[""]*len(B) for _ in range(len(A))]

# 3. DP 테이블 채우기
for i in range(1, len(A)):
    for j in range(1, len(B)):
        # 경우 1: 두 문자가 같은 경우
        if A[i] == B[j]:
            # 대각선 왼쪽 위 값에 현재 문자를 붙임
            LCS[i][j] = LCS[i-1][j-1] + A[i]
        # 경우 2: 두 문자가 다른 경우
        else:
            # 왼쪽과 위쪽 중 더 긴 LCS를 선택해서 가져옴
            if len(LCS[i-1][j]) >= len(LCS[i][j-1]):
                LCS[i][j] = LCS[i-1][j]
            else:
                LCS[i][j] = LCS[i][j-1]

# 4. 결과 출력
result = LCS[-1][-1]
print(len(result))
print(result)</pre>
        </div>
        
        <div class="code-content code-java">
<pre>import java.io.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        
        // 1. 입력 받기
        String s1 = br.readLine();
        String s2 = br.readLine();
        int n = s1.length();
        int m = s2.length();
        
        // 2. DP 테이블 초기화 (길이 저장용)
        int[][] dp = new int[n + 1][m + 1];
        
        // 3. LCS 길이 구하기 (Bottom-Up)
        for(int i=1; i<=n; i++) {
            for(int j=1; j<=m; j++) {
                // 문자가 같으면 대각선 값 + 1
                if(s1.charAt(i-1) == s2.charAt(j-1)) {
                    dp[i][j] = dp[i-1][j-1] + 1;
                } 
                // 문자가 다르면 왼쪽이나 위쪽 중 큰 값 가져오기
                else {
                    dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);
                }
            }
        }
        
        // 4. 역추적 (Backtracking)으로 문자열 구하기
        // DP 테이블의 끝(우측 하단)에서 시작하여 역으로 추적
        StringBuilder sb = new StringBuilder();
        int i = n, j = m;
        
        while(i > 0 && j > 0) {
            // 4-1. 위쪽 값과 같다면 위로 이동 (현재 문자가 LCS에 포함 안 됨)
            if(dp[i][j] == dp[i-1][j]) {
                i--;
            }
            // 4-2. 왼쪽 값과 같다면 왼쪽으로 이동
            else if(dp[i][j] == dp[i][j-1]) {
                j--;
            }
            // 4-3. 둘 다 아니라면(대각선에서 옴), 이 문자가 LCS의 일부임
            else {
                sb.append(s1.charAt(i-1));
                i--; j--;
            }
        }
        
        // 역순으로 찾았으므로 뒤집어서 출력
        System.out.println(dp[n][m]);
        System.out.println(sb.reverse());
    }
}</pre>
        </div>
        
        <div class="code-content code-js">
<pre>const fs = require('fs');
const [s1, s2] = fs.readFileSync('/dev/stdin').toString().trim().split('\n');

const n = s1.length;
const m = s2.length;
// DP 테이블 생성 (0으로 초기화)
const dp = Array.from({length: n + 1}, () => Array(m + 1).fill(0));

// 1. DP 테이블 채우기 (길이 계산)
for(let i=1; i<=n; i++) {
    for(let j=1; j<=m; j++) {
        // 문자가 같을 때
        if(s1[i-1] === s2[j-1]) dp[i][j] = dp[i-1][j-1] + 1;
        // 문자가 다를 때: 이전 값 중 최댓값 유지
        else dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);
    }
}

console.log(dp[n][m]);

// 2. 역추적하여 실제 문자열 찾기
let i = n, j = m;
let result = [];

while(i > 0 && j > 0) {
    // 위쪽 값과 같으면 위로 이동
    if(dp[i][j] === dp[i-1][j]) i--;
    // 왼쪽 값과 같으면 왼쪽으로 이동
    else if(dp[i][j] === dp[i][j-1]) j--;
    // 대각선에서 온 경우 (현재 문자 매칭됨)
    else {
        result.push(s1[i-1]);
        i--; j--;
    }
}

// 역순으로 담겼으므로 뒤집어서 합침
console.log(result.reverse().join(''));</pre>
        </div>
    </div>

    <div id="p1915" class="problem-container">
        <h2>6. 가장 큰 정사각형 (1915번)</h2>
        <div class="description">
            n×m의 0, 1로 된 배열이 있다. 이 배열에서 1로 된 가장 큰 정사각형의 크기를 구하는 프로그램을 작성하시오.
        </div>
        <div class="example-box">
            <div>
                <span class="io-header">예제 입력</span>
                <pre>4 4
0100
0111
1110
0010</pre>
            </div>
            <div>
                <span class="io-header">예제 출력</span>
                <pre>4</pre>
            </div>
        </div>

        <div class="code-tabs">
            <button class="tab-button active" onclick="openTab(event, 'p1915', 'py')">Python</button>
            <button class="tab-button" onclick="openTab(event, 'p1915', 'java')">Java</button>
            <button class="tab-button" onclick="openTab(event, 'p1915', 'js')">JavaScript</button>
        </div>

        <div class="code-content code-py active">
<pre>import sys
input = sys.stdin.readline

n, m = map(int, input().split())
board = [list(map(int, list(input().strip()))) for _ in range(n)]

max_side = 0

for i in range(n):
    for j in range(m):
        if i > 0 and j > 0 and board[i][j] == 1:
            board[i][j] += min(board[i][j-1], board[i-1][j], board[i-1][j-1])
            
        max_side = max(max_side, board[i][j])

print(max_side ** 2)</pre>
        </div>
        <div class="code-content code-java">
<pre>import java.io.*;
import java.util.StringTokenizer;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int m = Integer.parseInt(st.nextToken());
        int[][] dp = new int[n][m];
        int maxSide = 0;

        for(int i=0; i<n; i++) {
            String line = br.readLine();
            for(int j=0; j<m; j++) {
                dp[i][j] = line.charAt(j) - '0';
                if(i>0 && j>0 && dp[i][j] == 1) {
                    dp[i][j] = Math.min(dp[i-1][j-1], Math.min(dp[i-1][j], dp[i][j-1])) + 1;
                }
                maxSide = Math.max(maxSide, dp[i][j]);
            }
        }
        System.out.println(maxSide * maxSide);
    }
}</pre>
        </div>
        <div class="code-content code-js">
<pre>const fs = require('fs');
const input = fs.readFileSync('/dev/stdin').toString().trim().split('\n');
const [n, m] = input[0].split(' ').map(Number);
const board = input.slice(1).map(line => line.split('').map(Number));

let maxSide = 0;

for (let i = 0; i < n; i++) {
    for (let j = 0; j < m; j++) {
        if (i > 0 && j > 0 && board[i][j] === 1) {
            board[i][j] = Math.min(board[i-1][j], board[i][j-1], board[i-1][j-1]) + 1;
        }
        if (board[i][j] > maxSide) maxSide = board[i][j];
    }
}
console.log(maxSide * maxSide);</pre>
        </div>
    </div>

    <div id="p11049" class="problem-container">
        <h2>7. 행렬 곱셈 순서 (11049번)</h2>
        <div class="description">
            크기가 N×M인 행렬 A와 M×K인 행렬 B를 곱할 때 필요한 곱셈 연산의 수는 N×M×K이다.<br>
            행렬 N개의 크기가 주어졌을 때, 모든 행렬을 곱하는데 필요한 곱셈 연산 횟수의 최솟값을 구하는 프로그램을 작성하시오.
        </div>
        <div class="example-box">
            <div>
                <span class="io-header">예제 입력</span>
                <pre>3
5 3
3 2
2 6</pre>
            </div>
            <div>
                <span class="io-header">예제 출력</span>
                <pre>90</pre>
            </div>
        </div>

        <div class="code-tabs">
            <button class="tab-button active" onclick="openTab(event, 'p11049', 'py')">Python</button>
            <button class="tab-button" onclick="openTab(event, 'p11049', 'java')">Java</button>
            <button class="tab-button" onclick="openTab(event, 'p11049', 'js')">JavaScript</button>
        </div>

        <div class="code-content code-py active">
<pre>import sys
input = sys.stdin.readline
N = int(input())
matrix = []
for _ in range(N):
    matrix.append(list(map(int, input().split())))
dp =[[0 for _ in range(N)] for _ in range(N)] 


for i in range(1, N): #몇 번째 대각선?
    for j in range(0, N-i): #대각선에서 몇 번째 열?
    
        if i == 1: #차이가 1밖에 나지 않는 칸
            dp[j][j+i] = matrix[j][0] * matrix[j][1] * matrix[j+i][1]
            continue
        
        dp[j][j+i] = 2**32 #최댓값을 미리 넣어줌
        for k in range(j, j+i): 
            dp[j][j+i] = min(dp[j][j+i], 
                             dp[j][k] + dp[k+1][j+i] + matrix[j][0] * matrix[k][1] * matrix[j+i][1])
                
print(dp[0][N-1])</pre>
        </div>
        <div class="code-content code-java">
<pre>import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        int[][] mat = new int[N][2];
        for(int i=0; i<N; i++) {
            mat[i][0] = sc.nextInt();
            mat[i][1] = sc.nextInt();
        }
        
        int[][] dp = new int[N][N];
        
        for(int len=1; len<N; len++) {
            for(int i=0; i<N-len; i++) {
                int j = i + len;
                dp[i][j] = Integer.MAX_VALUE;
                for(int k=i; k<j; k++) {
                    int cost = dp[i][k] + dp[k+1][j] + mat[i][0] * mat[k][1] * mat[j][1];
                    dp[i][j] = Math.min(dp[i][j], cost);
                }
            }
        }
        System.out.println(dp[0][N-1]);
    }
}</pre>
        </div>
        <div class="code-content code-js">
<pre>const fs = require('fs');
const input = fs.readFileSync('/dev/stdin').toString().trim().split('\n');
const N = Number(input[0]);
const matrix = input.slice(1).map(line => line.split(' ').map(Number));

const dp = Array.from({length: N}, () => Array(N).fill(0));

for (let len = 1; len < N; len++) {
    for (let i = 0; i < N - len; i++) {
        let j = i + len;
        dp[i][j] = Infinity;
        for (let k = i; k < j; k++) {
            let cost = dp[i][k] + dp[k+1][j] + matrix[i][0] * matrix[k][1] * matrix[j][1];
            dp[i][j] = Math.min(dp[i][j], cost);
        }
    }
}
console.log(dp[0][N-1]);</pre>
        </div>
    </div>

    <div id="p2098" class="problem-container">
        <h2>8. 외판원 순회 (2098번)</h2>
        <div class="description">
            1번부터 N번까지 번호가 매겨져 있는 도시들이 있고, 도시들 사이에는 길이 있다.<br>
            어느 한 도시에서 출발해 N개의 도시를 모두 거쳐 다시 원래의 도시로 돌아오는 순회 여행 경로를 계획하려고 한다.<br>
            가장 적은 비용을 들이는 여행 계획을 세우는 프로그램을 작성하시오.
        </div>
        <div class="example-box">
            <div>
                <span class="io-header">예제 입력</span>
                <pre>4
0 10 15 20
5 0 9 10
6 13 0 12
8 8 9 0</pre>
            </div>
            <div>
                <span class="io-header">예제 출력</span>
                <pre>35</pre>
            </div>
        </div>

        <div class="code-tabs">
            <button class="tab-button active" onclick="openTab(event, 'p2098', 'py')">Python</button>
            <button class="tab-button" onclick="openTab(event, 'p2098', 'java')">Java</button>
            <button class="tab-button" onclick="openTab(event, 'p2098', 'js')">JavaScript</button>
        </div>

        <div class="code-content code-py active">
<pre>import sys
input = sys.stdin.readline
INF = float('inf')

N = int(input())
W = [list(map(int, input().split())) for _ in range(N)]

dp = [[-1] * (1 << N) for _ in range(N)]

def dfs(now, visited):
    if visited == (1 << N) - 1:
        return W[now][0] if W[now][0] > 0 else INF

    if dp[now][visited] != -1:
        return dp[now][visited]

    dp[now][visited] = INF
    
    for next_node in range(1, N):
        if W[now][next_node] == 0 or (visited & (1 << next_node)):
            continue
        
        dp[now][visited] = min(dp[now][visited], dfs(next_node, visited | (1 << next_node)) + W[now][next_node])

    return dp[now][visited]

print(dfs(0, 1))</pre>
        </div>
        <div class="code-content code-java">
<pre>import java.util.Arrays;
import java.util.Scanner;

public class Main {
    static int N;
    static int[][] W;
    static int[][] dp;
    static final int INF = 16000000;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        N = sc.nextInt();
        W = new int[N][N];
        dp = new int[N][1 << N];
        for(int i=0; i<N; i++) {
            Arrays.fill(dp[i], -1);
            for(int j=0; j<N; j++) W[i][j] = sc.nextInt();
        }
        System.out.println(dfs(0, 1));
    }

    static int dfs(int now, int visited) {
        if (visited == (1 << N) - 1) {
            if (W[now][0] == 0) return INF;
            return W[now][0];
        }
        if (dp[now][visited] != -1) return dp[now][visited];

        dp[now][visited] = INF;
        for (int i = 0; i < N; i++) {
            if (W[now][i] == 0 || (visited & (1 << i)) != 0) continue;
            dp[now][visited] = Math.min(dp[now][visited], dfs(i, visited | (1 << i)) + W[now][i]);
        }
        return dp[now][visited];
    }
}</pre>
        </div>
        <div class="code-content code-js">
<pre>const fs = require('fs');
const input = fs.readFileSync('/dev/stdin').toString().trim().split('\n');
const N = Number(input[0]);
const W = input.slice(1).map(line => line.split(' ').map(Number));
const INF = 1e9;
const dp = Array.from({length: N}, () => Array(1 << N).fill(-1));

function dfs(now, visited) {
    if (visited === (1 << N) - 1) {
        return W[now][0] === 0 ? INF : W[now][0];
    }
    if (dp[now][visited] !== -1) return dp[now][visited];

    let minCost = INF;
    for (let i = 0; i < N; i++) {
        if (W[now][i] !== 0 && !(visited & (1 << i))) {
            minCost = Math.min(minCost, dfs(i, visited | (1 << i)) + W[now][i]);
        }
    }
    return dp[now][visited] = minCost;
}

console.log(dfs(0, 1));</pre>
        </div>
    </div>

    <div id="p14003" class="problem-container">
        <h2>9. 가장 긴 증가하는 부분 수열 5 (14003번)</h2>
        <div class="description">
            수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 프로그램을 작성하시오.<br>
            예를 들어, A = {10, 20, 10, 30, 20, 50} 인 경우에 가장 긴 증가하는 부분 수열은 A = {10, 20, 30, 50} 이고, 길이는 4이다.
        </div>
        <div class="example-box">
            <div>
                <span class="io-header">예제 입력</span>
                <pre>6
10 20 10 30 20 50</pre>
            </div>
            <div>
                <span class="io-header">예제 출력</span>
                <pre>4
10 20 30 50</pre>
            </div>
        </div>

        <div class="code-tabs">
            <button class="tab-button active" onclick="openTab(event, 'p14003', 'py')">Python</button>
            <button class="tab-button" onclick="openTab(event, 'p14003', 'java')">Java</button>
            <button class="tab-button" onclick="openTab(event, 'p14003', 'js')">JavaScript</button>
        </div>

        <div class="code-content code-py active">
<pre>import sys
from bisect import bisect_left
input = sys.stdin.readline

N = int(input())
A = list(map(int, input().split()))

lis_arr = [A[0]]
record = [(0, A[0])]

for i in range(1, N):
    if A[i] > lis_arr[-1]:
        lis_arr.append(A[i])
        record.append((len(lis_arr) - 1, A[i]))
    else:
        idx = bisect_left(lis_arr, A[i])
        lis_arr[idx] = A[i]
        record.append((idx, A[i]))

print(len(lis_arr))

result = []
target_idx = len(lis_arr) - 1

for i in range(N - 1, -1, -1):
    if record[i][0] == target_idx:
        result.append(record[i][1])
        target_idx -= 1

print(*result[::-1])</pre>
        </div>
        <div class="code-content code-java">
<pre>import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int N = Integer.parseInt(br.readLine());
        StringTokenizer st = new StringTokenizer(br.readLine());
        int[] A = new int[N];
        for(int i=0; i<N; i++) A[i] = Integer.parseInt(st.nextToken());
        
        List<Integer> lis = new ArrayList<>();
        lis.add(A[0]);
        int[] indexRecord = new int[N]; // 각 원소가 LIS의 몇 번째에 들어갔는지 기록
        indexRecord[0] = 0;
        
        for(int i=1; i<N; i++) {
            if(A[i] > lis.get(lis.size()-1)) {
                lis.add(A[i]);
                indexRecord[i] = lis.size() - 1;
            } else {
                int idx = Collections.binarySearch(lis, A[i]);
                if(idx < 0) idx = -(idx + 1);
                lis.set(idx, A[i]);
                indexRecord[i] = idx;
            }
        }
        
        System.out.println(lis.size());
        Stack<Integer> stack = new Stack<>();
        int targetIdx = lis.size() - 1;
        
        for(int i=N-1; i>=0; i--) {
            if(indexRecord[i] == targetIdx) {
                stack.push(A[i]);
                targetIdx--;
            }
        }
        
        StringBuilder sb = new StringBuilder();
        while(!stack.isEmpty()) sb.append(stack.pop()).append(" ");
        System.out.println(sb);
    }
}</pre>
        </div>
        <div class="code-content code-js">
<pre>const fs = require('fs');
const input = fs.readFileSync('/dev/stdin').toString().trim().split('\n');
const N = Number(input[0]);
const A = input[1].split(' ').map(Number);

let lis = [A[0]];
let record = []; // [index in lis, value]
record.push([0, A[0]]);

function lowerBound(arr, target) {
    let left = 0, right = arr.length;
    while (left < right) {
        let mid = Math.floor((left + right) / 2);
        if (arr[mid] < target) left = mid + 1;
        else right = mid;
    }
    return right;
}

for (let i = 1; i < N; i++) {
    if (A[i] > lis[lis.length - 1]) {
        lis.push(A[i]);
        record.push([lis.length - 1, A[i]]);
    } else {
        let idx = lowerBound(lis, A[i]);
        lis[idx] = A[i];
        record.push([idx, A[i]]);
    }
}

console.log(lis.length);

let result = [];
let targetIdx = lis.length - 1;
for (let i = N - 1; i >= 0; i--) {
    if (record[i][0] === targetIdx) {
        result.push(record[i][1]);
        targetIdx--;
    }
}
console.log(result.reverse().join(' '));</pre>
        </div>
    </div>

    <div id="p11758" class="problem-container">
        <h2>10. CCW (11758번)</h2>
        <div class="description">
            2차원 좌표 평면 위에 있는 점 3개 P1, P2, P3가 주어진다. P1, P2, P3를 순서대로 이은 선분이 반시계 방향을 나타내면 1, 시계 방향이면 -1, 일직선이면 0을 출력하는 프로그램을 작성하시오.
        </div>
        <div class="example-box">
            <div>
                <span class="io-header">예제 입력</span>
                <pre>1 1
5 5
7 3</pre>
            </div>
            <div>
                <span class="io-header">예제 출력</span>
                <pre>-1</pre>
            </div>
        </div>

        <div class="code-tabs">
            <button class="tab-button active" onclick="openTab(event, 'p11758', 'py')">Python</button>
            <button class="tab-button" onclick="openTab(event, 'p11758', 'java')">Java</button>
            <button class="tab-button" onclick="openTab(event, 'p11758', 'js')">JavaScript</button>
        </div>

        <div class="code-content code-py active">
<pre>import sys
input = sys.stdin.readline

x1, y1 = map(int, input().split())
x2, y2 = map(int, input().split())
x3, y3 = map(int, input().split())

result = (x2 - x1) * (y3 - y1) - (x3 - x1) * (y2 - y1)

if result > 0:
    print(1)
elif result < 0:
    print(-1)
else:
    print(0)</pre>
        </div>
        <div class="code-content code-java">
<pre>import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int x1 = sc.nextInt(); int y1 = sc.nextInt();
        int x2 = sc.nextInt(); int y2 = sc.nextInt();
        int x3 = sc.nextInt(); int y3 = sc.nextInt();
        
        int result = (x2 - x1) * (y3 - y1) - (x3 - x1) * (y2 - y1);
        
        if (result > 0) System.out.println(1);
        else if (result < 0) System.out.println(-1);
        else System.out.println(0);
    }
}</pre>
        </div>
        <div class="code-content code-js">
<pre>const fs = require('fs');
const input = fs.readFileSync('/dev/stdin').toString().trim().split('\n');
const [x1, y1] = input[0].split(' ').map(Number);
const [x2, y2] = input[1].split(' ').map(Number);
const [x3, y3] = input[2].split(' ').map(Number);

const result = (x2 - x1) * (y3 - y1) - (x3 - x1) * (y2 - y1);

if (result > 0) console.log(1);
else if (result < 0) console.log(-1);
else console.log(0);</pre>
        </div>
    </div>

    <div id="p17387" class="problem-container">
        <h2>11. 선분 교차 2 (17387번)</h2>
        <div class="description">
            2차원 좌표 평면 위의 두 선분 L1, L2가 주어졌을 때, 두 선분이 교차하는지 아닌지 구하는 프로그램을 작성하시오.<br>
            교차하면 1, 아니면 0을 출력한다.
        </div>
        <div class="example-box">
            <div>
                <span class="io-header">예제 입력</span>
                <pre>1 1 5 5
3 3 7 7</pre>
            </div>
            <div>
                <span class="io-header">예제 출력</span>
                <pre>1</pre>
            </div>
        </div>

        <div class="code-tabs">
            <button class="tab-button active" onclick="openTab(event, 'p17387', 'py')">Python</button>
            <button class="tab-button" onclick="openTab(event, 'p17387', 'java')">Java</button>
            <button class="tab-button" onclick="openTab(event, 'p17387', 'js')">JavaScript</button>
        </div>

        <div class="code-content code-py active">
<pre>import sys
input = sys.stdin.readline

x1, y1, x2, y2 = map(int, input().split())
x3, y3, x4, y4 = map(int, input().split())

def ccw(x1, y1, x2, y2, x3, y3):
    temp = (x2 - x1) * (y3 - y1) - (x3 - x1) * (y2 - y1)
    if temp > 0: return 1
    elif temp < 0: return -1
    else: return 0

abc = ccw(x1, y1, x2, y2, x3, y3)
abd = ccw(x1, y1, x2, y2, x4, y4)
cda = ccw(x3, y3, x4, y4, x1, y1)
cdb = ccw(x3, y3, x4, y4, x2, y2)

res1 = abc * abd
res2 = cda * cdb

if res1 == 0 and res2 == 0:
    if (x1, y1) > (x2, y2): x1, y1, x2, y2 = x2, y2, x1, y1
    if (x3, y3) > (x4, y4): x3, y3, x4, y4 = x4, y4, x3, y3
    
    if (x1, y1) <= (x4, y4) and (x3, y3) <= (x2, y2):
        print(1)
    else:
        print(0)
elif res1 <= 0 and res2 <= 0:
    print(1)
else:
    print(0)</pre>
        </div>
        <div class="code-content code-java">
<pre>import java.util.Scanner;

public class Main {
    static int ccw(long x1, long y1, long x2, long y2, long x3, long y3) {
        long temp = (x2 - x1) * (y3 - y1) - (x3 - x1) * (y2 - y1);
        if (temp > 0) return 1;
        else if (temp < 0) return -1;
        return 0;
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        long x1 = sc.nextLong(), y1 = sc.nextLong();
        long x2 = sc.nextLong(), y2 = sc.nextLong();
        long x3 = sc.nextLong(), y3 = sc.nextLong();
        long x4 = sc.nextLong(), y4 = sc.nextLong();

        int abc = ccw(x1, y1, x2, y2, x3, y3);
        int abd = ccw(x1, y1, x2, y2, x4, y4);
        int cda = ccw(x3, y3, x4, y4, x1, y1);
        int cdb = ccw(x3, y3, x4, y4, x2, y2);

        if (abc * abd == 0 && cda * cdb == 0) {
            if (Math.min(x1, x2) <= Math.max(x3, x4) && Math.min(x3, x4) <= Math.max(x1, x2) &&
                Math.min(y1, y2) <= Math.max(y3, y4) && Math.min(y3, y4) <= Math.max(y1, y2)) {
                System.out.println(1);
            } else {
                System.out.println(0);
            }
        } else if (abc * abd <= 0 && cda * cdb <= 0) {
            System.out.println(1);
        } else {
            System.out.println(0);
        }
    }
}</pre>
        </div>
        <div class="code-content code-js">
<pre>const fs = require('fs');
const input = fs.readFileSync('/dev/stdin').toString().trim().split('\n');
const [x1, y1, x2, y2] = input[0].split(' ').map(Number);
const [x3, y3, x4, y4] = input[1].split(' ').map(Number);

function ccw(x1, y1, x2, y2, x3, y3) {
    const temp = (x2 - x1) * (y3 - y1) - (x3 - x1) * (y2 - y1);
    if (temp > 0) return 1;
    else if (temp < 0) return -1;
    return 0;
}

const abc = ccw(x1, y1, x2, y2, x3, y3);
const abd = ccw(x1, y1, x2, y2, x4, y4);
const cda = ccw(x3, y3, x4, y4, x1, y1);
const cdb = ccw(x3, y3, x4, y4, x2, y2);

const res1 = abc * abd;
const res2 = cda * cdb;

if (res1 === 0 && res2 === 0) {
    let p1 = {x: x1, y: y1}, p2 = {x: x2, y: y2};
    let p3 = {x: x3, y: y3}, p4 = {x: x4, y: y4};
    if (p1.x > p2.x || (p1.x === p2.x && p1.y > p2.y)) [p1, p2] = [p2, p1];
    if (p3.x > p4.x || (p3.x === p4.x && p3.y > p4.y)) [p3, p4] = [p4, p3];

    if (p1.x <= p4.x && p1.y <= Math.max(p3.y, p4.y) && 
        p3.x <= p2.x && p3.y <= Math.max(p1.y, p2.y) && 
        ((x1 <= x4 && x1 >= x3) || (x3 <= x2 && x3 >= x1) || (y1 <= y4 && y1 >= y3) || (y3 <= y2 && y3 >= y1))) {
         if (Math.min(x1, x2) <= Math.max(x3, x4) && Math.min(x3, x4) <= Math.max(x1, x2) &&
             Math.min(y1, y2) <= Math.max(y3, y4) && Math.min(y3, y4) <= Math.max(y1, y2)) {
             console.log(1);
         } else console.log(0);
    } else console.log(0);
} else if (res1 <= 0 && res2 <= 0) {
    console.log(1);
} else {
    console.log(0);
}</pre>
        </div>
    </div>

    <div id="p2162" class="problem-container">
        <h2>12. 선분 그룹 (2162번)</h2>
        <div class="description">
            N개의 선분들이 주어졌을 때, 서로 만나는 선분끼리는 같은 그룹에 속한다고 정의한다.<br>
            이때 그룹의 개수와 가장 크기가 큰 그룹에 속한 선분의 개수를 구하시오.
        </div>
        <div class="example-box">
            <div>
                <span class="io-header">예제 입력</span>
                <pre>3
1 1 2 3
2 1 0 0
1 0 1 1</pre>
            </div>
            <div>
                <span class="io-header">예제 출력</span>
                <pre>1
3</pre>
            </div>
        </div>

        <div class="code-tabs">
            <button class="tab-button active" onclick="openTab(event, 'p2162', 'py')">Python</button>
            <button class="tab-button" onclick="openTab(event, 'p2162', 'java')">Java</button>
            <button class="tab-button" onclick="openTab(event, 'p2162', 'js')">JavaScript</button>
        </div>

        <div class="code-content code-py active">
<pre>import sys
input = sys.stdin.readline

def ccw(x1, y1, x2, y2, x3, y3):
    tmp = (x2 - x1) * (y3 - y1) - (x3 - x1) * (y2 - y1)
    if tmp > 0: return 1
    elif tmp < 0: return -1
    return 0

def is_cross(l1, l2):
    x1, y1, x2, y2 = l1
    x3, y3, x4, y4 = l2
    abc = ccw(x1, y1, x2, y2, x3, y3) * ccw(x1, y1, x2, y2, x4, y4)
    cdab = ccw(x3, y3, x4, y4, x1, y1) * ccw(x3, y3, x4, y4, x2, y2)
    if abc == 0 and cdab == 0:
        if (x1, y1) > (x2, y2): x1, y1, x2, y2 = x2, y2, x1, y1
        if (x3, y3) > (x4, y4): x3, y3, x4, y4 = x4, y4, x3, y3
        return (x1, y1) <= (x4, y4) and (x3, y3) <= (x2, y2)
    return abc <= 0 and cdab <= 0

def find(x):
    if parent[x] != x:
        parent[x] = find(parent[x])
    return parent[x]

def union(a, b):
    a = find(a)
    b = find(b)
    if a != b:
        parent[b] = a

N = int(input())
lines = [list(map(int, input().split())) for _ in range(N)]
parent = [i for i in range(N)]

for i in range(N):
    for j in range(i + 1, N):
        if is_cross(lines[i], lines[j]):
            union(i, j)

parent = [find(i) for i in range(N)]
group_count = len(set(parent))
max_group_size = max([parent.count(i) for i in set(parent)])

print(group_count)
print(max_group_size)</pre>
        </div>
        <div class="code-content code-java">
<pre>import java.util.*;

public class Main {
    static int[] parent;
    static int find(int x) {
        if(parent[x] == x) return x;
        return parent[x] = find(parent[x]);
    }
    static void union(int a, int b) {
        a = find(a); b = find(b);
        if(a != b) parent[b] = a;
    }
    
    static int ccw(int x1, int y1, int x2, int y2, int x3, int y3) {
        long res = (long)(x2-x1)*(y3-y1) - (long)(x3-x1)*(y2-y1);
        if(res > 0) return 1;
        if(res < 0) return -1;
        return 0;
    }
    
    static boolean isCross(int[] l1, int[] l2) {
        int x1=l1[0], y1=l1[1], x2=l1[2], y2=l1[3];
        int x3=l2[0], y3=l2[1], x4=l2[2], y4=l2[3];
        
        int abc = ccw(x1,y1,x2,y2,x3,y3) * ccw(x1,y1,x2,y2,x4,y4);
        int cdab = ccw(x3,y3,x4,y4,x1,y1) * ccw(x3,y3,x4,y4,x2,y2);
        
        if(abc == 0 && cdab == 0) {
            if(Math.min(x1, x2) <= Math.max(x3, x4) && Math.min(x3, x4) <= Math.max(x1, x2) &&
               Math.min(y1, y2) <= Math.max(y3, y4) && Math.min(y3, y4) <= Math.max(y1, y2)) return true;
            return false;
        }
        return abc <= 0 && cdab <= 0;
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        int[][] lines = new int[N][4];
        for(int i=0; i<N; i++) for(int j=0; j<4; j++) lines[i][j] = sc.nextInt();
        
        parent = new int[N];
        for(int i=0; i<N; i++) parent[i] = i;
        
        for(int i=0; i<N; i++) {
            for(int j=i+1; j<N; j++) {
                if(isCross(lines[i], lines[j])) union(i, j);
            }
        }
        
        Map<Integer, Integer> map = new HashMap<>();
        for(int i=0; i<N; i++) {
            int root = find(i);
            map.put(root, map.getOrDefault(root, 0) + 1);
        }
        
        int max = 0;
        for(int val : map.values()) max = Math.max(max, val);
        System.out.println(map.size());
        System.out.println(max);
    }
}</pre>
        </div>
        <div class="code-content code-js">
<pre>const fs = require('fs');
const input = fs.readFileSync('/dev/stdin').toString().trim().split('\n');
const N = Number(input[0]);
const lines = input.slice(1).map(line => line.split(' ').map(Number));
let parent = Array.from({length: N}, (_, i) => i);

function find(x) {
    if (parent[x] === x) return x;
    return parent[x] = find(parent[x]);
}
function union(a, b) {
    a = find(a); b = find(b);
    if (a !== b) parent[b] = a;
}
function ccw(x1, y1, x2, y2, x3, y3) {
    let tmp = (x2 - x1) * (y3 - y1) - (x3 - x1) * (y2 - y1);
    if (tmp > 0) return 1;
    if (tmp < 0) return -1;
    return 0;
}
function isCross(l1, l2) {
    let [x1, y1, x2, y2] = l1;
    let [x3, y3, x4, y4] = l2;
    let abc = ccw(x1, y1, x2, y2, x3, y3) * ccw(x1, y1, x2, y2, x4, y4);
    let cdab = ccw(x3, y3, x4, y4, x1, y1) * ccw(x3, y3, x4, y4, x2, y2);
    
    if (abc === 0 && cdab === 0) {
        return Math.min(x1, x2) <= Math.max(x3, x4) && Math.min(x3, x4) <= Math.max(x1, x2) &&
               Math.min(y1, y2) <= Math.max(y3, y4) && Math.min(y3, y4) <= Math.max(y1, y2);
    }
    return abc <= 0 && cdab <= 0;
}

for (let i = 0; i < N; i++) {
    for (let j = i + 1; j < N; j++) {
        if (isCross(lines[i], lines[j])) union(i, j);
    }
}

let counts = {};
for (let i = 0; i < N; i++) {
    let root = find(i);
    counts[root] = (counts[root] || 0) + 1;
}

let maxVal = 0;
let groupCount = 0;
for (let k in counts) {
    groupCount++;
    if (counts[k] > maxVal) maxVal = counts[k];
}
console.log(groupCount);
console.log(maxVal);</pre>
        </div>
    </div>

    <div id="p2166" class="problem-container">
        <h2>13. 다각형의 면적 (2166번)</h2>
        <div class="description">
            2차원 평면상에 N개의 점으로 이루어진 다각형이 있다. 이 다각형의 면적을 구하는 프로그램을 작성하시오.
        </div>
        <div class="example-box">
            <div>
                <span class="io-header">예제 입력</span>
                <pre>4
0 0
0 10
10 10
10 0</pre>
            </div>
            <div>
                <span class="io-header">예제 출력</span>
                <pre>100.0</pre>
            </div>
        </div>

        <div class="code-tabs">
            <button class="tab-button active" onclick="openTab(event, 'p2166', 'py')">Python</button>
            <button class="tab-button" onclick="openTab(event, 'p2166', 'java')">Java</button>
            <button class="tab-button" onclick="openTab(event, 'p2166', 'js')">JavaScript</button>
        </div>

        <div class="code-content code-py active">
<pre>import sys
input = sys.stdin.readline

N = int(input())
points = [list(map(int, input().split())) for _ in range(N)]

points.append(points[0])

x_sum = 0
y_sum = 0

for i in range(N):
    x_sum += points[i][0] * points[i+1][1]
    y_sum += points[i][1] * points[i+1][0]

area = abs(x_sum - y_sum) / 2

print(f"{area:.1f}")</pre>
        </div>
        <div class="code-content code-java">
<pre>import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        long[] x = new long[N + 1];
        long[] y = new long[N + 1];
        
        for(int i=0; i<N; i++) {
            x[i] = sc.nextLong();
            y[i] = sc.nextLong();
        }
        x[N] = x[0];
        y[N] = y[0];
        
        long sumA = 0;
        long sumB = 0;
        
        for(int i=0; i<N; i++) {
            sumA += x[i] * y[i+1];
            sumB += x[i+1] * y[i];
        }
        
        System.out.printf("%.1f", Math.abs(sumA - sumB) / 2.0);
    }
}</pre>
        </div>
        <div class="code-content code-js">
<pre>const fs = require('fs');
const input = fs.readFileSync('/dev/stdin').toString().trim().split('\n');
const N = Number(input[0]);
const points = input.slice(1).map(line => line.split(' ').map(Number));
points.push(points[0]);

let sumA = 0;
let sumB = 0;

for(let i=0; i<N; i++) {
    sumA += points[i][0] * points[i+1][1];
    sumB += points[i+1][0] * points[i][1];
}

console.log((Math.abs(sumA - sumB) / 2).toFixed(1));</pre>
        </div>
    </div>

</body>
</html>