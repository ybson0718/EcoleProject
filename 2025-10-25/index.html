<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>알고리즘 문제 풀이 (18352 상세 해설 + 질문 포함)</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            background-color: #f8f9fa;
            color: #212529;
            margin: 0;
            padding: 20px;
        }
        .container {
            max-width: 900px;
            margin: 0 auto;
            background-color: #ffffff;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 24px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
        }
        h1 {
            text-align: center;
            color: #007bff;
            border-bottom: 2px solid #007bff;
            padding-bottom: 10px;
            margin-top: 0;
        }
        h2 {
            color: #343a40;
            border-bottom: 1px solid #e9ecef;
            padding-bottom: 8px;
            margin-top: 40px;
        }
        h3 {
            color: #495057;
            margin-top: 24px;
        }
        p {
            color: #495057;
        }
        pre {
            background-color: #f1f3f5;
            border: 1px solid #ced4da;
            border-radius: 5px;
            padding: 16px;
            overflow-x: auto;
            font-size: 0.9em;
            line-height: 1.4;
        }
        code {
            font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace;
        }
        .problem-section {
            margin-bottom: 40px;
            border-bottom: 2px solid #007bff;
            padding-bottom: 20px;
        }
        
        /* 상세 해설용 스타일 */
        .detailed-explanation {
            background-color: #fdfdfd;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }
        .concept-box {
            background-color: #e6f7ff;
            border: 1px solid #b3e0ff;
            border-radius: 5px;
            padding: 16px;
            margin: 20px 0;
        }
        .graph-container {
            text-align: center;
            padding: 20px;
            background: #fdfdfd;
            border-radius: 8px;
            border: 1px solid #eee;
        }
        .step {
            margin-bottom: 20px;
            padding-bottom: 20px;
            border-bottom: 1px dashed #ced4da;
        }
        .step:last-child {
            border-bottom: none;
        }
        /* 질문 박스 스타일 */
        .question-box {
            background-color: #fffaf0; 
            border: 1px solid #ffe5b4;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }
        .question-box ol {
            padding-left: 20px;
        }
        .question-box li {
            margin-bottom: 10px;
        }

        /* 탭 스타일 */
        .tab-buttons {
            display: flex;
            border-bottom: 2px solid #dee2e6;
            margin-bottom: -1px; /* Overlap with pre border */
        }
        .tab-button {
            padding: 10px 16px;
            cursor: pointer;
            background-color: #e9ecef;
            border: 1px solid #dee2e6;
            border-bottom: none;
            border-radius: 5px 5px 0 0;
            margin-right: 5px;
            font-weight: 500;
            color: #495057;
            position: relative;
            bottom: -2px; /* Align with border */
        }
        .tab-button.active {
            background-color: #f1f3f5;
            border-color: #ced4da;
            border-bottom: 2px solid #f1f3f5; /* Hide bottom border */
            color: #007bff;
        }
        .tab-content {
            display: none;
            border-top: none;
            margin-top: -2px; /* Overlap with buttons */
        }
        .tab-content.active {
            display: block;
        }
        /* Basic Syntax Highlighting */
        .code-python .comment { color: #6a9955; }
        .code-python .keyword { color: #007bff; }
        .code-python .string { color: #d69d85; }
        
        .code-java .comment { color: #6a9955; }
        .code-java .keyword { color: #007bff; }
        .code-java .type { color: #267f99; }
        .code-java .string { color: #d69d85; }
        
        .code-javascript .comment { color: #6a9955; }
        .code-javascript .keyword { color: #007bff; }
        .code-javascript .string { color: #d69d85; }
    </style>
</head>
<body>

    <div class="container">
        <h1>백준 알고리즘 문제 풀이</h1>

        <!-- 문제 1: 18352 특정 거리의 도시 찾기 -->
        <div class="problem-section">
            <h2>1. 백준 18352번: 특정 거리의 도시 찾기 (실버 II)</h2>
            
            <!-- 상세 해설 섹션 -->
            <div class="detailed-explanation">
                <h3>[상세 해설] 부산 지하철 예시로 이해하기</h3>
                
                <h4>1. 문제의 핵심: "최단 거리"와 "모든 도로=1"</h4>
                <p>
                    이 문제는 특정 도시 X에서 출발하여 다른 도시까지의 <strong>최단 거리</strong>를 묻고 있습니다.
                    여기서 가장 중요한 단서는 <strong>"모든 도로의 거리가 1"</strong>이라는 점입니다.
                </p>
                <p>
                    이것을 부산 지하철 노선도에 비유해 볼게요.<br>
                    <strong>"모든 역 사이의 이동 거리는 1이다"</strong>라고 가정하는 것입니다. (즉, 환승이나 이동 횟수 1)
                </p>
                <p>
                    이렇게 한 단계(거리 1)씩 차근차근 탐색해 나가는 방식을 <strong>너비 우선 탐색 (BFS, Breadth-First Search)</strong>이라고 부릅니다. BFS는 모든 "간선(도로)"의 가중치가 1일 때 최단 거리를 찾는 가장 빠른 방법입니다.
                </p>

                <h4>2. 부산 지하철 노선으로 예제 살펴보기</h4>
                <p>
                    이해를 돕기 위해, 간단한 <strong>가상의 부산 지하철 노선도</strong>를 만들어 BFS 과정을 단계별로 살펴보겠습니다.
                </p>
                <p>
                    <strong>조건: K=2 (찾는 거리), X='서면역' (출발 도시)</strong>
                    <br>
                    <strong>문제:</strong> "서면역에서 출발하여, 정확히 2번 이동(거리 2)해서 도착할 수 있는 모든 역을 찾으시오."
                </p>
                <div class="graph-container">
                    <p><strong>[가상 노선도 (수정 Ver.)]</strong></p>
                    <ul style="list-style-type: none; padding-left: 0;">
                        <li><strong>서면(X)</strong>은 <strong>부산역</strong>, <strong>연산역</strong>, <strong>수영역</strong>과 연결되어 있다. (거리 1)</li>
                        <li><strong>부산역</strong>은 <strong>남포역</strong>과 연결되어 있다.</li>
                        <li><strong>연산역</strong>은 <strong>덕천역</strong>과 <strong>동래역</strong>과 연결되어 있다.</li>
                        <li><strong>수영역</strong>은 <strong>광안역</strong>과 <strong>해운대역</strong>과 연결되어 있다.</li>
                    </ul>

                    <!-- SVG 다이어그램 시작 -->
                    <svg viewBox="0 0 600 320" width="100%" height="auto" style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; text-anchor: middle; margin-top: 20px;">
                        <style>
                            .line { stroke: #adb5bd; stroke-width: 2; }
                            .node-l0 { fill: #007bff; }
                            .text-l0 { fill: white; font-weight: bold; font-size: 14px; }
                            .node-l1 { fill: #e6f7ff; stroke: #007bff; stroke-width: 2; }
                            .text-l1 { fill: #0056b3; font-weight: 500; font-size: 14px; }
                            .node-l2 { fill: #f8f9fa; stroke: #adb5bd; stroke-width: 1; }
                            .text-l2 { fill: #212529; font-size: 14px; }
                            .level-label { font-size: 12px; fill: #6c757d; font-weight: bold; text-anchor: start; }
                        </style>
                
                        <!-- 레벨 레이블 -->
                        <text x="10" y="55" class="level-label">거리 0 (K=0)</text>
                        <line x1="100" y1="50" x2="590" y2="50" style="stroke: #e9ecef; stroke-dasharray: 4;"/>
                        <text x="10" y="155" class="level-label">거리 1 (K=1)</text>
                        <line x1="100" y1="150" x2="590" y2="150" style="stroke: #e9ecef; stroke-dasharray: 4;"/>
                        <text x="10" y="255" class="level-label">거리 2 (K=2)</text>
                        <line x1="100" y1="250" x2="590" y2="250" style="stroke: #e9ecef; stroke-dasharray: 4;"/>
                
                        <!-- 라인 (노드보다 먼저 그려야 뒤로 감) -->
                        <line x1="300" y1="50" x2="150" y2="150" class="line" />
                        <line x1="300" y1="50" x2="300" y2="150" class="line" />
                        <line x1="300" y1="50" x2="450" y2="150" class="line" />
                        
                        <line x1="150" y1="150" x2="150" y2="250" class="line" />
                        
                        <line x1="300" y1="150" x2="250" y2="250" class="line" />
                        <line x1="300" y1="150" x2="350" y2="250" class="line" />
                        
                        <line x1="450" y1="150" x2="420" y2="250" class="line" />
                        <line x1="450" y1="150" x2="480" y2="250" class="line" />
                
                        <!-- 노드 Layer 0 -->
                        <g>
                            <circle cx="300" cy="50" r="25" class="node-l0" />
                            <text x="300" y="55" class="text-l0">서면</text>
                        </g>
                        
                        <!-- 노드 Layer 1 -->
                        <g>
                            <circle cx="150" cy="150" r="25" class="node-l1" />
                            <text x="150" y="155" class="text-l1">부산역</text>
                        </g>
                        <g>
                            <circle cx="300" cy="150" r="25" class="node-l1" />
                            <text x="300" y="155" class="text-l1">연산</text>
                        </g>
                        <g>
                            <circle cx="450" cy="150" r="25" class="node-l1" />
                            <text x="450" y="155" class="text-l1">수영</text>
                        </g>
                
                        <!-- 노드 Layer 2 (K=2 정답) -->
                        <g>
                            <circle cx="150" cy="250" r="25" class="node-l2" style="stroke: #007bff; stroke-width: 2; fill: #e6f7ff;"/>
                            <text x="150" y="255" class="text-l2" style="font-weight: bold;">남포</text>
                        </g>
                        <g>
                            <circle cx="250" cy="250" r="25" class="node-l2" style="stroke: #007bff; stroke-width: 2; fill: #e6f7ff;"/>
                            <text x="250" y="255" class="text-l2" style="font-weight: bold;">덕천</text>
                        </g>
                        <g>
                            <circle cx="350" cy="250" r="25" class="node-l2" style="stroke: #007bff; stroke-width: 2; fill: #e6f7ff;"/>
                            <text x="350" y="255" class="text-l2" style="font-weight: bold;">동래</text>
                        </g>
                        <g>
                            <circle cx="420" cy="250" r="25" class="node-l2" style="stroke: #007bff; stroke-width: 2; fill: #e6f7ff;"/>
                            <text x="420" y="255" class="text-l2" style="font-weight: bold;">광안</text>
                        </g>
                        <g>
                            <circle cx="480" cy="250" r="25" class="node-l2" style="stroke: #007bff; stroke-width: 2; fill: #e6f7ff;"/>
                            <text x="480" y="255" class="text-l2" style="font-weight: bold;">해운대</text>
                        </g>
                    </svg>
                    <!-- SVG 다이어그램 끝 -->
                </div>
                
                <p style="margin-top: 20px;">
                    우리는 2가지 도구를 사용합니다.
                    <br>
                    1. <strong>방문할 역 목록 (Queue):</strong> 다음에 방문할 역들을 순서대로 저장하는 '대기열'입니다.
                    <br>
                    2. <strong>거리 기록 배열 (distance):</strong> 각 역까지의 최단 거리를 기록합니다. (처음엔 모두 -1, '서면'은 0)
                </p>

                <div class="step">
                    <h3>시작 (거리 0)</h3>
                    <p>
                        - <code>distance</code>: {서면: <strong>0</strong>, 부산역: -1, 연산: -1, 수영: -1, 남포: -1, 덕천: -1, 동래: -1, 광안: -1, 해운대: -1}
                        <br>
                        - <code>Queue</code>: [ <strong>서면</strong> ] (서면역에서 탐색 시작)
                    </p>
                </div>
                
                <div class="step">
                    <h3>1단계 (거리 1 탐색)</h3>
                    <p>
                        1. Queue에서 <strong>'서면'</strong>을 꺼냅니다.
                        <br>
                        2. '서면'과 직접 연결된 역(부산역, 연산역, 수영역)을 찾습니다.
                        <br>
                        3. 모두 미방문(-1)이므로, 거리를 1로 갱신하고 Queue에 넣습니다.
                    </p>
                    <p>
                        - <code>distance</code>: {서면: 0, <strong>부산역: 1</strong>, <strong>연산: 1</strong>, <strong>수영: 1</strong>, 남포: -1, 덕천: -1, 동래: -1, 광안: -1, 해운대: -1}
                        <br>
                        - <code>Queue</code>: [ <strong>부산역</strong>, <strong>연산</strong>, <strong>수영</strong> ]
                    </p>
                </div>

                <div class="step">
                    <h3>2단계 (거리 2 탐색)</h3>
                    <p>
                        Queue에서 순서대로 꺼냅니다.
                        <br>
                        1. <strong>'부산역'</strong> (1)을 꺼냄 -> '남포' 발견
                        <br>
                        &nbsp;&nbsp;&nbsp; - '남포'는 미방문(-1). `distance[남포] = distance[부산역] + 1 = 2`
                        <br>
                        &nbsp;&nbsp;&nbsp; - Queue에 '남포' 추가. (Queue: [연산, 수영, <strong>남포</strong>])
                        <br>
                        <br>
                        2. <strong>'연산'</strong> (1)을 꺼냄 -> '덕천', '동래' 발견
                        <br>
                        &nbsp;&nbsp;&nbsp; - '덕천'은 미방문(-1). `distance[덕천] = distance[연산] + 1 = 2`
                        <br>
                        &nbsp;&nbsp;&nbsp; - Queue에 '덕천' 추가. (Queue: [수영, 남포, <strong>덕천</strong>])
                        <br>
                        &nbsp;&nbsp;&nbsp; - '동래'는 미방문(-1). `distance[동래] = distance[연산] + 1 = 2`
                        <br>
                        &nbsp;&nbsp;&nbsp; - Queue에 '동래' 추가. (Queue: [수영, 남포, 덕천, <strong>동래</strong>])
                        <br>
                        <br>
                        3. <strong>'수영'</strong> (1)을 꺼냄 -> '광안', '해운대' 발견
                        <br>
                        &nbsp;&nbsp;&nbsp; - '광안'은 미방문(-1). `distance[광안] = distance[수영] + 1 = 2`
                        <br>
                        &nbsp;&nbsp;&nbsp; - Queue에 '광안' 추가. (Queue: [남포, 덕천, 동래, <strong>광안</strong>])
                        <br>
                        &nbsp;&nbsp;&nbsp; - '해운대'는 미방문(-1). `distance[해운대] = distance[수영] + 1 = 2`
                        <br>
                        &nbsp;&nbsp;&nbsp; - Queue에 '해운대' 추가. (Queue: [남포, 덕천, 동래, 광안, <strong>해운대</strong>])
                    </p>
                </div>

                <div class="step">
                    <h3>3단계 (탐색 종료)</h3>
                    <p>
                        1. Queue에 남은 '남포', '덕천', '동래', '광안', '해운대' (모두 거리 2)를 차례로 꺼냅니다.
                        <br>
                        2. 이 역들에서는 더 이상 연결된 새로운 역이 없으므로, 아무 일도 일어나지 않고 탐색이 종료됩니다.
                        <br>
                        3. Queue가 모두 비었습니다. <strong>탐색 종료.</strong>
                    </p>
                    <p>
                        - <strong>최종 <code>distance</code> 배열:</strong>
                        <br>
                        {서면: 0, 부산역: 1, 연산: 1, 수영: 1, <strong>남포: 2</strong>, <strong>덕천: 2</strong>, <strong>동래: 2</strong>, <strong>광안: 2</strong>, <strong>해운대: 2</strong>}
                    </p>
                </div>

                <h3>3. 정답 찾기 (K=2)</h3>
                <p>
                    이제 최종 <code>distance</code> 배열을 보고, 우리가 찾던 <strong>거리(K) = 2</strong> 인 역들을 찾으면 됩니다.
                </p>
                <div class="concept-box">
                    - <code>distance[남포] = 2</code> <strong>(O)</strong>
                    <br>
                    - <code>distance[덕천] = 2</code> <strong>(O)</strong>
                    <br>
                    - <code>distance[동래] = 2</code> <strong>(O)</strong>
                    <br>
                    - <code>distance[광안] = 2</code> <strong>(O)</strong>
                    <br>
                    - <code>distance[해운대] = 2</code> <strong>(O)</strong>
                </div>
                <p>
                    따라서 "서면역에서 정확히 2번 이동해서 갈 수 있는 도시"는 <strong>남포역</strong>, <strong>덕천역</strong>, <strong>동래역</strong>, <strong>광안역</strong>, <strong>해운대역</strong>입니다!
                </p>
            </div>
            <!-- 상세 해설 끝 -->

            <!-- === 10개 질문 섹션 === -->
            <h3>[참고] 18352번 문제: AI에게 물어보기 좋은 질문 10가지</h3>
            <div class="question-box">
                <p>이 문제의 원리를 더 깊게 파악하기 위해 AI에게 물어볼 수 있는 좋은 질문들입니다.</p>
                <ol>
                    <li><strong>[코드 로직]</strong>
                        "BFS 코드의 `while`문 안에 `if distance[next_node] == -1:` 라는 검사 부분이 있습니다. 이 검사가 왜 꼭 필요한가요? 만약 이 `if`문이 없다면 코드에 어떤 문제가 생길 수 있나요?"</li>
                    <li><strong>[알고리즘 선택 이유]</strong>
                        "18352번 문제를 푸는 데 왜 '너비 우선 탐색(BFS)'이 가장 좋은 방법인지 설명해 줘."</li>
                    <li><strong>[알고리즘 비교]</strong>
                        "이 문제를 다익스트라(Dijkstra) 알고리즘으로 풀 수도 있다던데, 굳이 BFS로 푸는 이유가 뭐야? 다익스트라로 풀면 안 되는 거야?"</li>
                    <li><strong>[핵심 자료구조]</strong>
                        "BFS 코드에서 `queue`(큐) 자료구조가 하는 역할이 정확히 뭐야? 만약 큐 대신 스택(Stack)을 쓰면 어떻게 되는지 알려줘."</li>
                    <li><strong>[핵심 변수]</strong>
                        "`distance` 배열을 전부 `-1`로 초기화하는 이유가 뭐야? 이 배열이 '방문 여부'와 '거리'를 어떻게 동시에 기록할 수 있는지 설명해 줘."</li>
                    <li><strong>[코드 동작 원리]</strong>
                        "BFS가 어떻게 '최단' 거리를 보장하는지 궁금해. 1번에서 3번으로 바로 가는 길(거리 1)이랑, 1번에서 2번을 거쳐 3번으로 가는 길(거리 2)이 둘 다 있다면, 왜 항상 거리 1을 먼저 찾게 돼?"</li>
                    <li><strong>[문제 변형 1]</strong>
                        "지금 코드는 거리가 정확히 'K'인 도시만 찾는데, 만약 'K 이하'인 모든 도시를 찾아야 한다면 코드를 어떻게 바꿔야 해?"</li>
                    <li><strong>[문제 변형 2]</strong>
                        "만약 '모든 도로의 거리가 1'이라는 조건이 없어지고, '도로마다 거리가 1, 2, 3... 처럼 다를 수 있다'라고 문제가 바뀌면, 지금 이 BFS 코드는 왜 정답을 못 찾아?"</li>
                    <li><strong>[예외 처리]</strong>
                        "만약 출발 도시 X에서 아무 데로도 갈 수 없거나, 거리가 K인 도시가 하나도 없을 때, 이 코드가 어떻게 `-1`을 출력하게 되는지 로직을 따라가면서 설명해 줘."</li>
                    <li><strong>[효율성]</strong>
                        "이 BFS 풀이의 시간 복잡도와 공간 복잡도를 알려줘. (N, M, K, X 중에서 어떤 값의 영향을 받는지?)"</li>
                </ol>
            </div>
            <!-- === 10개 질문 섹션 끝 === -->

            <h3>코드</h3>
            <div class="tab-container">
                <div class="tab-buttons">
                    <button class="tab-button" onclick="showTab(event, 'py-18352')">Python</button>
                    <button class="tab-button" onclick="showTab(event, 'java-18352')">Java</button>
                    <button class="tab-button" onclick="showTab(event, 'js-18352')">JavaScript</button>
                </div>

                <div id="py-18352" class="tab-content code-python">
<pre><code class="language-python">
<span class="comment"># 18352: 특정 거리의 도시 찾기</span>
<span class="keyword">import</span> sys
<span class="keyword">from</span> collections <span class="keyword">import</span> deque

<span class="comment"># 빠른 입력을 위해 sys.stdin.readline 사용</span>
input = sys.stdin.readline

N, M, K, X = map(int, input().split())
graph = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(N + 1)]

<span class="comment"># 그래프 정보 (단방향)</span>
<span class="keyword">for</span> _ <span class="keyword">in</span> range(M):
    A, B = map(int, input().split())
    graph[A].append(B)

<span class="comment"># 각 도시까지의 최단 거리를 저장할 리스트 (-1은 아직 방문 안 함)</span>
distance = [-1] * (N + 1)
<span class="comment"># 출발 도시의 거리는 0</span>
distance[X] = 0

<span class="comment"># BFS를 위한 큐</span>
queue = deque([X])

<span class="keyword">while</span> queue:
    current_node = queue.popleft()

    <span class="comment"># 현재 도시에서 이동할 수 있는 모든 도시를 확인</span>
    <span class="keyword">for</span> next_node <span class="keyword">in</span> graph[current_node]:
        <span class="comment"># 아직 방문하지 않은 도시라면</span>
        <span class="keyword">if</span> distance[next_node] == -1:
            <span class="comment"># 최단 거리 갱신</span>
            distance[next_node] = distance[current_node] + 1
            queue.append(next_node)

<span class="comment"># 최단 거리가 K인 모든 도시의 번호를 오름차순으로 출력</span>
found = False
<span class="keyword">for</span> i <span class="keyword">in</span> range(1, N + 1):
    <span class="keyword">if</span> distance[i] == K:
        print(i)
        found = True

<span class="comment"># 최단 거리가 K인 도시가 없다면 -1 출력</span>
<span class="keyword">if</span> <span class="keyword">not</span> found:
    print(-1)
</code></pre>
                </div>
                <div id="java-18352" class="tab-content code-java">
<pre><code class="language-java">
<span class="comment">// 18352: 특정 거리의 도시 찾기</span>
<span class="keyword">import</span> java.io.BufferedReader;
<span class="keyword">import</span> java.io.InputStreamReader;
<span class="keyword">import</span> java.io.IOException;
<span class="keyword">import</span> java.util.ArrayList;
<span class="keyword">import</span> java.util.LinkedList;
<span class="keyword">import</span> java.util.Queue;
<span class="keyword">import</span> java.util.StringTokenizer;
<span class="keyword">import</span> java.util.Collections;

<span class="keyword">public</span> <span class="type">class</span> Main {
    <span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> main(<span class="type">String</span>[] args) <span class="keyword">throws</span> IOException {
        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));
        StringTokenizer st = <span class="keyword">new</span> StringTokenizer(br.readLine());

        <span class="type">int</span> N = Integer.parseInt(st.nextToken()); <span class="comment">// 도시의 개수</span>
        <span class="type">int</span> M = Integer.parseInt(st.nextToken()); <span class="comment">// 도로의 개수</span>
        <span class="type">int</span> K = Integer.parseInt(st.nextToken()); <span class="comment">// 거리 정보</span>
        <span class="type">int</span> X = Integer.parseInt(st.nextToken()); <span class="comment">// 출발 도시</span>

        <span class="comment">// 그래프를 인접 리스트로 구현</span>
        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> ArrayList&lt;&gt;();
        <span class="keyword">for</span> (<span class="type">int</span> i = 0; i &lt;= N; i++) {
            graph.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());
        }

        <span class="keyword">for</span> (<span class="type">int</span> i = 0; i < M; i++) {
            st = <span class="keyword">new</span> StringTokenizer(br.readLine());
            <span class="type">int</span> A = Integer.parseInt(st.nextToken());
            <span class="type">int</span> B = Integer.parseInt(st.nextToken());
            graph.get(A).add(B);
        }

        <span class="comment">// 최단 거리 저장 배열 (-1로 초기화)</span>
        <span class="type">int</span>[] distance = <span class="keyword">new</span> <span class="type">int</span>[N + 1];
        <span class="keyword">for</span> (<span class="type">int</span> i = 0; i &lt;= N; i++) {
            distance[i] = -1;
        }

        <span class="comment">// BFS 시작</span>
        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();
        queue.add(X);
        distance[X] = 0;

        <span class="keyword">while</span> (!queue.isEmpty()) {
            <span class="type">int</span> current_node = queue.poll();

            <span class="keyword">for</span> (<span class="type">int</span> next_node : graph.get(current_node)) {
                <span class="comment">// 아직 방문하지 않은 도시라면</span>
                <span class="keyword">if</span> (distance[next_node] == -1) {
                    distance[next_node] = distance[current_node] + 1;
                    queue.add(next_node);
                }
            }
        }

        <span class="comment">// 결과 출력을 위한 리스트</span>
        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();
        <span class="keyword">for</span> (<span class="type">int</span> i = 1; i &lt;= N; i++) {
            <span class="keyword">if</span> (distance[i] == K) {
                result.add(i);
            }
        }

        <span class="comment">// 결과 출력</span>
        <span class="keyword">if</span> (result.isEmpty()) {
            System.out.println(-1);
        } <span class="keyword">else</span> {
            StringBuilder sb = <span class="keyword">new</span> StringBuilder();
            <span class="keyword">for</span> (<span class="type">int</span> node : result) {
                sb.append(node).append(<span class="string">"\n"</span>);
            }
            System.out.print(sb.toString());
        }
    }
}
</code></pre>
                </div>
                <div id="js-18352" class="tab-content code-javascript">
<pre><code class="language-javascript">
<span class="comment">// 18352: 특정 거리의 도시 찾기</span>
<span class="keyword">const</span> fs = <span class="keyword">require</span>(<span class="string">'fs'</span>);
<span class="comment">// 백준 제출 시 /dev/stdin</span>
<span class="keyword">const</span> input = fs.readFileSync(<span class="string">'/dev/stdin'</span>).toString().trim().split(<span class="string">'\n'</span>);

<span class="keyword">const</span> [N, M, K, X] = input[0].split(<span class="string">' '</span>).map(Number);
<span class="keyword">const</span> graph = <span class="keyword">new</span> Array(N + 1).fill(0).map(() => []);

<span class="keyword">for</span> (<span class="keyword">let</span> i = 1; i &lt;= M; i++) {
    <span class="keyword">const</span> [A, B] = input[i].split(<span class="string">' '</span>).map(Number);
    graph[A].push(B);
}

<span class="comment">// 거리 배열, -1로 초기화</span>
<span class="keyword">const</span> distance = <span class="keyword">new</span> Array(N + 1).fill(-1);
distance[X] = 0;

<span class="comment">// BFS를 위한 큐 (JavaScript 배열로 큐 구현)</span>
<span class="keyword">const</span> queue = [X];
<span class="keyword">let</span> head = 0; <span class="comment">// shift()는 비효율적이므로 포인터 사용</span>

<span class="keyword">while</span> (head &lt; queue.length) {
    <span class="keyword">const</span> current_node = queue[head++];

    <span class="keyword">for</span> (<span class="keyword">const</span> next_node <span class="keyword">of</span> graph[current_node]) {
        <span class="keyword">if</span> (distance[next_node] === -1) {
            distance[next_node] = distance[current_node] + 1;
            queue.push(next_node);
        }
    }
}

<span class="keyword">const</span> result = [];
<span class="keyword">for</span> (<span class="keyword">let</span> i = 1; i &lt;= N; i++) {
    <span class="keyword">if</span> (distance[i] === K) {
        result.push(i);
    }
}

<span class="keyword">if</span> (result.length === 0) {
    console.log(-1);
} <span class="keyword">else</span> {
    console.log(result.join(<span class="string">'\n'</span>));
}
</code></pre>
                </div>
            </div>
        </div>

        <!-- 문제 2: 1707 이분 그래프 판별하기 -->
        <div class="problem-section">
            <h2>2. 백준 1707번: 이분 그래프 판별하기 (골드 IV)</h2>
            <h3>문제 해석</h3>
            <p>
                그래프의 정점들을 두 개의 그룹으로 나눌 때, 같은 그룹에 속한 정점끼리는 서로 인접하지 않도록(간선이 없도록) 만들 수 있다면 그 그래프를 **이분 그래프**라고 합니다. 이 문제는 주어진 그래프가 이분 그래프인지 아닌지를 판별하는 문제입니다.
                <br>
                이 문제는 **BFS** 또는 **DFS**를 사용하여 해결할 수 있습니다. 각 정점을 '방문 안 함(0)', '1번 그룹(1)', '2번 그룹(-1)'으로 구분합니다.
                <br>
                1. 아직 방문하지 않은 정점에서부터 탐색(BFS/DFS)을 시작하고, 해당 정점을 1번 그룹으로 칠합니다.
                <br>
                2. 해당 정점과 인접한 정점들은 2번 그룹(-1)으로 칠합니다.
                <br>
                3. 탐색을 계속 진행하면서, 만약 이미 칠해진 정점을 만나게 되었을 때, 현재 정점과 인접한 정점의 색(그룹)이 같다면 이분 그래프가 아닙니다.
                <br>
                4. 그래프가 여러 개의 컴포넌트로 나뉘어 있을 수 있으므로, 모든 정점을 방문할 때까지 이 과정을 반복해야 합니다.
            </p>
            <h3>코드</h3>
            <div class="tab-container">
                <div class="tab-buttons">
                    <button class="tab-button" onclick="showTab(event, 'py-1707')">Python</button>
                    <button class="tab-button" onclick="showTab(event, 'java-1707')">Java</button>
                    <button class="tab-button" onclick="showTab(event, 'js-1707')">JavaScript</button>
                </div>

                <div id="py-1707" class="tab-content code-python">
<pre><code class="language-python">
<span class="comment"># 1707: 이분 그래프 판별하기</span>
<span class="keyword">import</span> sys
<span class="keyword">from</span> collections <span class="keyword">import</span> deque
sys.setrecursionlimit(200000) <span class="comment"># DFS/BFS 깊이 제한 해제</span>
input = sys.stdin.readline

<span class="keyword">def</span> bfs(start_node, group):
    queue = deque([start_node])
    group[start_node] = 1 <span class="comment"># 1번 그룹으로 시작</span>
    
    <span class="keyword">while</span> queue:
        current_node = queue.popleft()
        
        <span class="keyword">for</span> next_node <span class="keyword">in</span> graph[current_node]:
            <span class="comment"># 아직 방문(그룹 할당) 안 했다면</span>
            <span class="keyword">if</span> group[next_node] == 0:
                group[next_node] = -group[current_node] <span class="comment"># 반대 그룹으로 할당</span>
                queue.append(next_node)
            <span class="comment"># 이미 방문했는데 같은 그룹이라면</span>
            <span class="keyword">elif</span> group[next_node] == group[current_node]:
                <span class="keyword">return</span> False <span class="comment"># 이분 그래프가 아님</span>
    <span class="keyword">return</span> True <span class="comment"># 현재 컴포넌트는 이분 그래프임</span>

K = int(input()) <span class="comment"># 테스트 케이스 개수</span>

<span class="keyword">for</span> _ <span class="keyword">in</span> range(K):
    V, E = map(int, input().split())
    graph = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(V + 1)]
    group = [0] * (V + 1) <span class="comment"># 0: 방문 안함, 1: 1번그룹, -1: 2번그룹</span>
    
    <span class="keyword">for</span> _ <span class="keyword">in</span> range(E):
        u, v = map(int, input().split())
        graph[u].append(v)
        graph[v].append(u)
        
    is_bipartite = True
    <span class="comment"># 모든 정점에 대해 확인 (연결이 끊긴 그래프 대비)</span>
    <span class="keyword">for</span> i <span class="keyword">in</span> range(1, V + 1):
        <span class="keyword">if</span> group[i] == 0: <span class="comment"># 아직 방문 안 한 정점에서 BFS 시작</span>
            <span class="keyword">if</span> <span class="keyword">not</span> bfs(i, group):
                is_bipartite = False
                <span class="keyword">break</span>
                
    <span class="keyword">if</span> is_bipartite:
        print(<span class="string">"YES"</span>)
    <span class="keyword">else</span>:
        print(<span class="string">"NO"</span>)
</code></pre>
                </div>
                <div id="java-1707" class="tab-content code-java">
<pre><code class="language-java">
<span class="comment">// 1707: 이분 그래프 판별하기</span>
<span class="keyword">import</span> java.io.BufferedReader;
<span class="keyword">import</span> java.io.InputStreamReader;
<span class="keyword">import</span> java.io.IOException;
<span class="keyword">import</span> java.util.ArrayList;
<span class="keyword">import</span> java.util.LinkedList;
<span class="keyword">import</span> java.util.Queue;
<span class="keyword">import</span> java.util.StringTokenizer;

<span class="keyword">public</span> <span class="type">class</span> Main {
    <span class="type">static</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; graph;
    <span class="type">static</span> <span class="type">int</span>[] group; <span class="comment">// 0: 방문 안함, 1: 1번 그룹, -1: 2번 그룹</span>
    
    <span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> main(<span class="type">String</span>[] args) <span class="keyword">throws</span> IOException {
        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));
        <span class="type">int</span> K = Integer.parseInt(br.readLine()); <span class="comment">// 테스트 케이스</span>
        StringBuilder sb = <span class="keyword">new</span> StringBuilder();

        <span class="keyword">while</span> (K-- > 0) {
            StringTokenizer st = <span class="keyword">new</span> StringTokenizer(br.readLine());
            <span class="type">int</span> V = Integer.parseInt(st.nextToken());
            <span class="type">int</span> E = Integer.parseInt(st.nextToken());

            graph = <span class="keyword">new</span> ArrayList&lt;&gt;();
            <span class="keyword">for</span> (<span class="type">int</span> i = 0; i &lt;= V; i++) {
                graph.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());
            }
            group = <span class="keyword">new</span> <span class="type">int</span>[V + 1];
            
            <span class="keyword">for</span> (<span class="type">int</span> i = 0; i < E; i++) {
                st = <span class="keyword">new</span> StringTokenizer(br.readLine());
                <span class="type">int</span> u = Integer.parseInt(st.nextToken());
                <span class="type">int</span> v = Integer.parseInt(st.nextToken());
                graph.get(u).add(v);
                graph.get(v).add(u);
            }

            <span class="type">boolean</span> isBipartite = <span class="keyword">true</span>;
            <span class="keyword">for</span> (<span class="type">int</span> i = 1; i &lt;= V; i++) {
                <span class="keyword">if</span> (group[i] == 0) { <span class="comment">// 아직 방문 안 한 컴포넌트</span>
                    <span class="keyword">if</span> (!bfs(i)) {
                        isBipartite = <span class="keyword">false</span>;
                        <span class="keyword">break</span>;
                    }
                }
            }
            sb.append(isBipartite ? <span class="string">"YES"</span> : <span class="string">"NO"</span>).append(<span class="string">'\n'</span>);
        }
        System.out.print(sb.toString());
    }

    <span class="type">static</span> <span class="type">boolean</span> bfs(<span class="type">int</span> startNode) {
        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();
        queue.add(startNode);
        group[startNode] = 1; <span class="comment">// 1번 그룹으로 시작</span>

        <span class="keyword">while</span> (!queue.isEmpty()) {
            <span class="type">int</span> currentNode = queue.poll();

            <span class="keyword">for</span> (<span class="type">int</span> nextNode : graph.get(currentNode)) {
                <span class="keyword">if</span> (group[nextNode] == 0) { <span class="comment">// 미방문</span>
                    group[nextNode] = -group[currentNode]; <span class="comment">// 반대 그룹 할당</span>
                    queue.add(nextNode);
                } <span class="keyword">else</span> <span class="keyword">if</span> (group[nextNode] == group[currentNode]) {
                    <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 이분 그래프 아님</span>
                }
            }
        }
        <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// 이분 그래프임</span>
    }
}
</code></pre>
                </div>
                <div id="js-1707" class="tab-content code-javascript">
<pre><code class="language-javascript">
<span class="comment">// 1707: 이분 그래프 판별하기</span>
<span class="keyword">const</span> fs = <span class="keyword">require</span>(<span class="string">'fs'</span>);
<span class="keyword">const</span> input = fs.readFileSync(<span class="string">'/dev/stdin'</span>).toString().trim().split(<span class="string">'\n'</span>);

<span class="keyword">let</span> lineIndex = 0;
<span class="keyword">const</span> K = +input[lineIndex++]; <span class="comment">// 테스트 케이스 수</span>
<span class="keyword">const</span> results = [];

<span class="comment">// BFS 함수</span>
<span class="keyword">function</span> bfs(startNode, V, graph, group) {
    <span class="keyword">const</span> queue = [startNode];
    group[startNode] = 1; <span class="comment">// 1번 그룹</span>

    <span class="keyword">let</span> head = 0;
    <span class="keyword">while</span> (head <span class="keyword">in</span> queue) {
        <span class="keyword">const</span> currentNode = queue[head++];

        <span class="keyword">for</span> (<span class="keyword">const</span> nextNode <span class="keyword">of</span> graph[currentNode]) {
            <span class="keyword">if</span> (group[nextNode] === 0) { <span class="comment">// 미방문</span>
                group[nextNode] = -group[currentNode]; <span class="comment">// 반대 그룹 할당</span>
                queue.push(nextNode);
            } <span class="keyword">else</span> <span class="keyword">if</span> (group[nextNode] === group[currentNode]) {
                <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 이분 그래프 아님</span>
            }
        }
    }
    <span class="keyword">return</span> <span class="keyword">true</span>;
}

<span class="keyword">for</span> (<span class="keyword">let</span> t = 0; t < K; t++) {
    <span class="keyword">const</span> [V, E] = input[lineIndex++].split(<span class="string">' '</span>).map(Number);
    <span class="keyword">const</span> graph = <span class="keyword">new</span> Array(V + 1).fill(0).map(() => []);
    <span class="keyword">const</span> group = <span class="keyword">new</span> Array(V + 1).fill(0); <span class="comment">// 0: 미방문, 1, -1</span>

    <span class="keyword">for</span> (<span class="keyword">let</span> e = 0; e < E; e++) {
        <span class="keyword">const</span> [u, v] = input[lineIndex++].split(<span class="string">' '</span>).map(Number);
        graph[u].push(v);
        graph[v].push(u);
    }

    <span class="keyword">let</span> isBipartite = <span class="keyword">true</span>;
    <span class="keyword">for</span> (<span class="keyword">let</span> i = 1; i &lt;= V; i++) {
        <span class="keyword">if</span> (group[i] === 0) {
            <span class="keyword">if</span> (!bfs(i, V, graph, group)) {
                isBipartite = <span class="keyword">false</span>;
                <span class="keyword">break</span>;
            }
        }
    }
    results.push(isBipartite ? <span class="string">"YES"</span> : <span class="string">"NO"</span>);
}

console.log(results.join(<span class="string">'\n'</span>));
</code></pre>
                </div>
            </div>
        </div>
        
        <!-- 문제 3: 1717 집합 표현하기 -->
        <div class="problem-section">
            <h2>3. 백준 1717번: 집합 표현하기 (골드 IV)</h2>
            <h3>문제 해석</h3>
            <p>
                초기에 $n+1$개의 집합 $\{0\}, \{1\}, ..., \{n\}$이 있습니다. 여기에 두 가지 연산을 수행합니다.
                <br>
                1. **합집합 (0 a b)**: $a$가 포함된 집합과 $b$가 포함된 집합을 합칩니다.
                <br>
                2. **포함 확인 (1 a b)**: $a$와 $b$가 같은 집합에 포함되어 있는지 확인하고, 그렇다면 "YES", 아니면 "NO"를 출력합니다.
                <br>
                이 문제는 **Union-Find (분리 집합)** 자료구조를 사용하여 효율적으로 해결할 수 있습니다. 각 원소의 '부모' 노드를 저장하는 배열을 만들고, `find` 연산(자신의 루트 노드를 찾음)과 `union` 연산(두 트리를 합침)을 구현합니다. 이때 `find` 연산 시 '경로 압축' 최적화를 적용해야 시간 초과가 발생하지 않습니다.
            </p>
            <h3>코드</h3>
            <div class="tab-container">
                <div class="tab-buttons">
                    <button class="tab-button" onclick="showTab(event, 'py-1717')">Python</button>
                    <button class="tab-button" onclick="showTab(event, 'java-1717')">Java</button>
                    <button class="tab-button" onclick="showTab(event, 'js-1717')">JavaScript</button>
                </div>

                <div id="py-1717" class="tab-content code-python">
<pre><code class="language-python">
<span class="comment"># 1717: 집합 표현하기</span>
<span class="keyword">import</span> sys
sys.setrecursionlimit(1000000) <span class="comment"># 재귀 깊이 제한 설정</span>
input = sys.stdin.readline

n, m = map(int, input().split())

<span class="comment"># 부모 테이블 초기화 (처음에는 자기 자신이 부모)</span>
parent = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(n + 1)]

<span class="comment"># 특정 원소가 속한 집합의 루트(대표)를 찾는 함수</span>
<span class="keyword">def</span> find_parent(x):
    <span class="comment"># 루트 노드가 아니라면, 루트 노드를 찾을 때까지 재귀 호출</span>
    <span class="keyword">if</span> parent[x] != x:
        parent[x] = find_parent(parent[x]) <span class="comment"># 경로 압축(Path Compression)</span>
    <span class="keyword">return</span> parent[x]

<span class="comment"># 두 원소가 속한 집합을 합치는 함수</span>
<span class="keyword">def</span> union_parent(a, b):
    a = find_parent(a)
    b = find_parent(b)
    <span class="keyword">if</span> a < b: <span class="comment"># 더 작은 번호를 부모로</span>
        parent[b] = a
    <span class="keyword">else</span>:
        parent[a] = b

<span class="comment"># m개의 연산 수행</span>
<span class="keyword">for</span> _ <span class="keyword">in</span> range(m):
    operation, a, b = map(int, input().split())
    
    <span class="keyword">if</span> operation == 0: <span class="comment"># 합집합 연산</span>
        union_parent(a, b)
    <span class="keyword">elif</span> operation == 1: <span class="comment"># 포함 확인 연산</span>
        <span class="keyword">if</span> find_parent(a) == find_parent(b):
            print(<span class="string">"YES"</span>)
        <span class="keyword">else</span>:
            print(<span class="string">"NO"</span>)
</code></pre>
                </div>
                <div id="java-1717" class="tab-content code-java">
<pre><code class="language-java">
<span class="comment">// 1717: 집합 표현하기</span>
<span class="keyword">import</span> java.io.BufferedReader;
<span class="keyword">import</span> java.io.InputStreamReader;
<span class="keyword">import</span> java.io.IOException;
<span class="keyword">import</span> java.util.StringTokenizer;

<span class="keyword">public</span> <span class="type">class</span> Main {
    <span class="type">static</span> <span class="type">int</span>[] parent;

    <span class="comment">// 루트 노드를 찾는 함수 (경로 압축 포함)</span>
    <span class="type">static</span> <span class="type">int</span> findParent(<span class="type">int</span> x) {
        <span class="keyword">if</span> (parent[x] == x) {
            <span class="keyword">return</span> x;
        }
        <span class="keyword">return</span> parent[x] = findParent(parent[x]);
    }

    <span class="comment">// 두 집합을 합치는 함수</span>
    <span class="type">static</span> <span class="type">void</span> unionParent(<span class="type">int</span> a, <span class="type">int</span> b) {
        a = findParent(a);
        b = findParent(b);
        <span class="keyword">if</span> (a != b) { <span class="comment">// 두 루트가 다를 때만 합침</span>
            <span class="keyword">if</span> (a < b) {
                parent[b] = a;
            } <span class="keyword">else</span> {
                parent[a] = b;
            }
        }
    }
    
    <span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> main(<span class="type">String</span>[] args) <span class="keyword">throws</span> IOException {
        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));
        StringTokenizer st = <span class="keyword">new</span> StringTokenizer(br.readLine());
        <span class="type">int</span> n = Integer.parseInt(st.nextToken());
        <span class="type">int</span> m = Integer.parseInt(st.nextToken());
        
        parent = <span class="keyword">new</span> <span class="type">int</span>[n + 1];
        <span class="keyword">for</span> (<span class="type">int</span> i = 0; i &lt;= n; i++) {
            parent[i] = i; <span class="comment">// 자기 자신으로 부모 초기화</span>
        }

        StringBuilder sb = <span class="keyword">new</span> StringBuilder();
        <span class="keyword">for</span> (<span class="type">int</span> i = 0; i < m; i++) {
            st = <span class="keyword">new</span> StringTokenizer(br.readLine());
            <span class="type">int</span> operation = Integer.parseInt(st.nextToken());
            <span class="type">int</span> a = Integer.parseInt(st.nextToken());
            <span class="type">int</span> b = Integer.parseInt(st.nextToken());

            <span class="keyword">if</span> (operation == 0) {
                unionParent(a, b);
            } <span class="keyword">else</span> {
                <span class="keyword">if</span> (findParent(a) == findParent(b)) {
                    sb.append(<span class="string">"YES"</span>).append(<span class="string">'\n'</span>);
                } <span class="keyword">else</span> {
                    sb.append(<span class="string">"NO"</span>).append(<span class="string">'\n'</span>);
                }
            }
        }
        System.out.print(sb.toString());
    }
}
</code></pre>
                </div>
                <div id="js-1717" class="tab-content code-javascript">
<pre><code class="language-javascript">
<span class="comment">// 1717: 집합 표현하기</span>
<span class="keyword">const</span> fs = <span class="keyword">require</span>(<span class="string">'fs'</span>);
<span class="keyword">const</span> input = fs.readFileSync(<span class="string">'/dev/stdin'</span>).toString().trim().split(<span class="string">'\n'</span>);

<span class="keyword">const</span> [n, m] = input[0].split(<span class="string">' '</span>).map(Number);
<span class="comment">// 부모 테이블 초기화</span>
<span class="keyword">const</span> parent = <span class="keyword">new</span> Array(n + 1).fill(0).map((_, i) => i);

<span class="comment">// 루트 노드 찾기 (경로 압축)</span>
<span class="keyword">function</span> findParent(x) {
    <span class="keyword">if</span> (parent[x] === x) {
        <span class="keyword">return</span> x;
    }
    <span class="comment">// 재귀적으로 루트를 찾으면서 부모를 루트로 갱신 (경로 압축)</span>
    <span class="keyword">return</span> (parent[x] = findParent(parent[x]));
}

<span class="comment">// 집합 합치기</span>
<span class="keyword">function</span> unionParent(a, b) {
    <span class="keyword">const</span> rootA = findParent(a);
    <span class="keyword">const</span> rootB = findParent(b);
    <span class="keyword">if</span> (rootA !== rootB) {
        <span class="keyword">if</span> (rootA < rootB) {
            parent[rootB] = rootA;
        } <span class="keyword">else</span> {
            parent[rootA] = rootB;
        }
    }
}

<span class="keyword">const</span> results = [];
<span class="keyword">for</span> (<span class="keyword">let</span> i = 1; i &lt;= m; i++) {
    <span class="keyword">const</span> [operation, a, b] = input[i].split(<span class="string">' '</span>).map(Number);
    
    <span class="keyword">if</span> (operation === 0) {
        unionParent(a, b);
    } <span class="keyword">else</span> {
        <span class="keyword">if</span> (findParent(a) === findParent(b)) {
            results.push(<span class="string">"YES"</span>);
        } <span class="keyword">else</span> {
            results.push(<span class="string">"NO"</span>);
        }
    }
}

console.log(results.join(<span class="string">'\n'</span>));
</code></pre>
                </div>
            </div>
        </div>
        
        <!-- 문제 4: 2252 줄 세우기 -->
        <div class="problem-section">
            <h2>4. 백준 2252번: 줄 세우기 (골드 III)</h2>
            <h3>문제 해석</h3>
            <p>
                N명의 학생들을 키 순서대로 줄 세우려고 합니다. 두 학생의 키를 비교한 M개의 결과가 주어지는데, 'A B'는 학생 A가 학생 B의 앞에 서야 한다는 의미입니다. 이 일부의 순서 정보를 바탕으로 전체 학생들을 줄 세운 결과를 하나 출력하는 문제입니다.
                <br>
                이 문제는 **위상 정렬 (Topological Sort)** 알고리즘을 사용하여 해결할 수 있습니다. 위상 정렬은 '선행 작업'이 있는 작업들의 순서를 정하는 알고리즘입니다.
                <br>
                1. 각 학생(노드)에 대해 자신을 가리키는 간선(자신보다 먼저 서야 하는 학생)의 수, 즉 **진입 차수(In-degree)**를 계산합니다.
                <br>
                2. 진입 차수가 0인 학생들을 큐에 넣습니다. (이 학생들은 가장 앞에 설 수 있습니다.)
                <br>
                3. 큐에서 학생을 한 명 꺼내 결과 리스트에 추가하고, 이 학생이 가리키는(이 학생 뒤에 서야 하는) 다른 학생들의 진입 차수를 1씩 감소시킵니다.
                <br>
                4. 만약 진입 차수가 0이 된 학생이 있다면, 그 학생도 큐에 넣습니다.
                <br>
                5. 큐가 빌 때까지 이 과정을 반복하면, 결과 리스트에 위상 정렬된 학생 순서가 담기게 됩니다.
            </p>
            <h3>코드</h3>
            <div class="tab-container">
                <div class="tab-buttons">
                    <button class="tab-button" onclick="showTab(event, 'py-2252')">Python</button>
                    <button class="tab-button" onclick="showTab(event, 'java-2252')">Java</button>
                    <button class="tab-button" onclick="showTab(event, 'js-2252')">JavaScript</button>
                </div>

                <div id="py-2252" class="tab-content code-python">
<pre><code class="language-python">
<span class="comment"># 2252: 줄 세우기</span>
<span class="keyword">import</span> sys
<span class="keyword">from</span> collections <span class="keyword">import</span> deque
input = sys.stdin.readline

N, M = map(int, input().split())

<span class="comment"># 진입 차수(in-degree) 리스트</span>
in_degree = [0] * (N + 1)
<span class="comment"># 그래프 (인접 리스트)</span>
graph = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(N + 1)]

<span class="keyword">for</span> _ <span class="keyword">in</span> range(M):
    A, B = map(int, input().split())
    graph[A].append(B) <span class="comment"># A가 B보다 앞에 선다 (A -> B)</span>
    in_degree[B] += 1  <span class="comment"># B의 진입 차수 증가</span>

<span class="comment"># 위상 정렬 함수</span>
<span class="keyword">def</span> topology_sort():
    result = [] <span class="comment"># 정렬 결과를 담을 리스트</span>
    queue = deque()

    <span class="comment"># 진입 차수가 0인 노드를 큐에 삽입</span>
    <span class="keyword">for</span> i <span class="keyword">in</span> range(1, N + 1):
        <span class="keyword">if</span> in_degree[i] == 0:
            queue.append(i)

    <span class="keyword">while</span> queue:
        current_node = queue.popleft()
        result.append(current_node)

        <span class="comment"># 현재 노드와 연결된 노드들의 진입 차수 1 빼기</span>
        <span class="keyword">for</span> next_node <span class="keyword">in</span> graph[current_node]:
            in_degree[next_node] -= 1
            <span class="comment"># 새롭게 진입 차수가 0이 되는 노드를 큐에 삽입</span>
            <span class="keyword">if</span> in_degree[next_node] == 0:
                queue.append(next_node)

    <span class="comment"># 결과 출력</span>
    print(*result)

topology_sort()
</code></pre>
                </div>
                <div id="java-2252" class="tab-content code-java">
<pre><code class="language-java">
<span class="comment">// 2252: 줄 세우기</span>
<span class="keyword">import</span> java.io.BufferedReader;
<span class="keyword">import</span> java.io.InputStreamReader;
<span class="keyword">import</span> java.io.IOException;
<span class="keyword">import</span> java.util.ArrayList;
<span class="keyword">import</span> java.util.LinkedList;
<span class="keyword">import</span> java.util.Queue;
<span class="keyword">import</span> java.util.StringTokenizer;

<span class="keyword">public</span> <span class="type">class</span> Main {
    <span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> main(<span class="type">String</span>[] args) <span class="keyword">throws</span> IOException {
        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));
        StringTokenizer st = <span class="keyword">new</span> StringTokenizer(br.readLine());

        <span class="type">int</span> N = Integer.parseInt(st.nextToken());
        <span class="type">int</span> M = Integer.parseInt(st.nextToken());

        <span class="type">int</span>[] inDegree = <span class="keyword">new</span> <span class="type">int</span>[N + 1];
        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> ArrayList&lt;&gt;();
        <span class="keyword">for</span> (<span class="type">int</span> i = 0; i &lt;= N; i++) {
            graph.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());
        }

        <span class="keyword">for</span> (<span class="type">int</span> i = 0; i < M; i++) {
            st = <span class="keyword">new</span> StringTokenizer(br.readLine());
            <span class="type">int</span> A = Integer.parseInt(st.nextToken());
            <span class="type">int</span> B = Integer.parseInt(st.nextToken());
            graph.get(A).add(B);
            inDegree[B]++;
        }

        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();
        <span class="comment">// 진입 차수가 0인 노드 큐에 삽입</span>
        <span class="keyword">for</span> (<span class="type">int</span> i = 1; i &lt;= N; i++) {
            <span class="keyword">if</span> (inDegree[i] == 0) {
                queue.add(i);
            }
        }

        StringBuilder sb = <span class="keyword">new</span> StringBuilder();
        <span class="keyword">while</span> (!queue.isEmpty()) {
            <span class="type">int</span> currentNode = queue.poll();
            sb.append(currentNode).append(<span class="string">" "</span>);

            <span class="keyword">for</span> (<span class="type">int</span> nextNode : graph.get(currentNode)) {
                inDegree[nextNode]--;
                <span class="keyword">if</span> (inDegree[nextNode] == 0) {
                    queue.add(nextNode);
                }
            }
        }
        System.out.println(sb.toString().trim());
    }
}
</code></pre>
                </div>
                <div id="js-2252" class="tab-content code-javascript">
<pre><code class="language-javascript">
<span class="comment">// 2252: 줄 세우기</span>
<span class="keyword">const</span> fs = <span class="keyword">require</span>(<span class="string">'fs'</span>);
<span class="keyword">const</span> input = fs.readFileSync(<span class="string">'/dev/stdin'</span>).toString().trim().split(<span class="string">'\n'</span>);

<span class="keyword">const</span> [N, M] = input[0].split(<span class="string">' '</span>).map(Number);

<span class="keyword">const</span> inDegree = <span class="keyword">new</span> Array(N + 1).fill(0);
<span class="keyword">const</span> graph = <span class="keyword">new</span> Array(N + 1).fill(0).map(() => []);

<span class="keyword">for</span> (<span class="keyword">let</span> i = 1; i &lt;= M; i++) {
    <span class="keyword">const</span> [A, B] = input[i].split(<span class="string">' '</span>).map(Number);
    graph[A].push(B);
    inDegree[B]++;
}

<span class="keyword">const</span> queue = [];
<span class="comment">// 진입 차수 0인 노드 큐에 추가</span>
<span class="keyword">for</span> (<span class="keyword">let</span> i = 1; i &lt;= N; i++) {
    <span class="keyword">if</span> (inDegree[i] === 0) {
        queue.push(i);
    }
}

<span class="keyword">const</span> result = [];
<span class="keyword">let</span> head = 0;
<span class="keyword">while</span> (head < queue.length) {
    <span class="keyword">const</span> currentNode = queue[head++];
    result.push(currentNode);

    <span class="keyword">for</span> (<span class="keyword">const</span> nextNode <span class="keyword">of</span> graph[currentNode]) {
        inDegree[nextNode]--;
        <span class="keyword">if</span> (inDegree[nextNode] === 0) {
            queue.push(nextNode);
        }
    }
}

console.log(result.join(<span class="string">' '</span>));
</code></pre>
                </div>
            </div>
        </div>
        
        <!-- 문제 5: 1516 게임 개발하기 -->
        <div class="problem-section">
            <h2>5. 백준 1516번: 게임 개발하기 (골드 III)</h2>
            <h3>문제 해석</h3>
            <p>
                N개의 건물을 지어야 합니다. 각 건물은 짓는 데 걸리는 시간이 있고, 일부 건물은 먼저 지어져야 하는 '선행 건물'들이 있습니다. 여러 건물을 동시에 지을 수 있을 때, 각 건물이 완성되기까지 걸리는 최소 시간을 출력하는 문제입니다.
                <br>
                이 문제 역시 **위상 정렬**을 응용하여 해결할 수 있습니다.
                <br>
                1. '줄 세우기' 문제와 동일하게 그래프와 진입 차수(in-degree)를 설정합니다.
                <br>
                2. 각 건물의 고유 건설 시간을 `time` 배열에 저장합니다.
                <br>
                3. 각 건물이 완성되는 '총 시간'을 저장할 `result_time` 배열을 만듭니다. (초기값은 `time` 배열과 동일)
                <br>
                4. 진입 차수가 0인 건물들을 큐에 넣습니다.
                <br>
                5. 큐에서 건물을 꺼낼 때, 해당 건물의 '다음 건물'(선행 건물이 해제되는 건물)들의 `result_time`을 갱신합니다.
                <br>
                6. 갱신 규칙은 다음과 같습니다: 
                `result_time[다음 건물] = max(result_time[다음 건물], result_time[현재 건물] + time[다음 건물])`
                <br>
                이 규칙은 '다음 건물'을 짓기 위해서는 모든 선행 건물들이 완성되어야 하므로, 가장 늦게 끝나는 선행 건물의 완료 시간(`result_time[현재 건물]`)을 기준으로 자신의 건설 시간(`time[다음 건물]`)을 더해야 한다는 의미입니다.
            </p>
            <h3>코드</h3>
            <div class="tab-container">
                <div class="tab-buttons">
                    <button class="tab-button" onclick="showTab(event, 'py-1516')">Python</button>
                    <button class="tab-button" onclick="showTab(event, 'java-1516')">Java</button>
                    <button class="tab-button" onclick="showTab(event, 'js-1516')">JavaScript</button>
                </div>

                <div id="py-1516" class="tab-content code-python">
<pre><code class="language-python">
<span class="comment"># 1516: 게임 개발하기</span>
<span class="keyword">import</span> sys
<span class="keyword">from</span> collections <span class="keyword">import</span> deque
input = sys.stdin.readline

N = int(input())

graph = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(N + 1)]
in_degree = [0] * (N + 1)
time = [0] * (N + 1) <span class="comment"># 각 건물 고유 건설 시간</span>
result_time = [0] * (N + 1) <span class="comment"># 각 건물 완성까지 걸리는 총 시간</span>

<span class="keyword">for</span> i <span class="keyword">in</span> range(1, N + 1):
    line = list(map(int, input().split()))
    time[i] = line[0] <span class="comment"># 건설 시간</span>
    result_time[i] = time[i] <span class="comment"># 초기 총 시간 = 고유 건설 시간</span>
    
    <span class="comment"># 선행 건물 정보 처리</span>
    <span class="keyword">for</span> j <span class="keyword">in</span> range(1, len(line) - 1):
        prerequisite = line[j]
        graph[prerequisite].append(i) <span class="comment"># 선행건물 -> 현재건물</span>
        in_degree[i] += 1

queue = deque()

<span class="comment"># 진입 차수가 0인 노드(건물) 큐에 삽입</span>
<span class="keyword">for</span> i <span class="keyword">in</span> range(1, N + 1):
    <span class="keyword">if</span> in_degree[i] == 0:
        queue.append(i)

<span class="keyword">while</span> queue:
    current_node = queue.popleft()

    <span class="keyword">for</span> next_node <span class="keyword">in</span> graph[current_node]:
        <span class="comment"># 다음 건물의 총 시간 갱신</span>
        <span class="comment"># (현재까지 계산된 다음 건물 시간) vs (현재 건물 완료시간 + 다음 건물 고유시간)</span>
        result_time[next_node] = max(result_time[next_node], result_time[current_node] + time[next_node])
        
        in_degree[next_node] -= 1
        <span class="keyword">if</span> in_degree[next_node] == 0:
            queue.append(next_node)

<span class="comment"># 결과 출력</span>
<span class="keyword">for</span> i <span class="keyword">in</span> range(1, N + 1):
    print(result_time[i])
</code></pre>
                </div>
                <div id="java-1516" class="tab-content code-java">
<pre><code class="language-java">
<span class="comment">// 1516: 게임 개발하기</span>
<span class="keyword">import</span> java.io.BufferedReader;
<span class="keyword">import</span> java.io.InputStreamReader;
<span class="keyword">import</span> java.io.IOException;
<span class="keyword">import</span> java.util.ArrayList;
<span class="keyword">import</span> java.util.LinkedList;
<span class="keyword">import</span> java.util.Queue;
<span class="keyword">import</span> java.util.StringTokenizer;

<span class="keyword">public</span> <span class="type">class</span> Main {
    <span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> main(<span class="type">String</span>[] args) <span class="keyword">throws</span> IOException {
        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));
        <span class="type">int</span> N = Integer.parseInt(br.readLine());

        <span class="type">int</span>[] inDegree = <span class="keyword">new</span> <span class="type">int</span>[N + 1];
        <span class="type">int</span>[] time = <span class="keyword">new</span> <span class="type">int</span>[N + 1]; <span class="comment">// 고유 건설 시간</span>
        <span class="type">int</span>[] resultTime = <span class="keyword">new</span> <span class="type">int</span>[N + 1]; <span class="comment">// 총 건설 시간</span>
        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> ArrayList&lt;&gt;();

        <span class="keyword">for</span> (<span class="type">int</span> i = 0; i &lt;= N; i++) {
            graph.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());
        }

        <span class="keyword">for</span> (<span class="type">int</span> i = 1; i &lt;= N; i++) {
            StringTokenizer st = <span class="keyword">new</span> StringTokenizer(br.readLine());
            time[i] = Integer.parseInt(st.nextToken());
            resultTime[i] = time[i]; <span class="comment">// 초기화</span>

            <span class="keyword">while</span> (<span class="keyword">true</span>) {
                <span class="type">int</span> prerequisite = Integer.parseInt(st.nextToken());
                <span class="keyword">if</span> (prerequisite == -1) {
                    <span class="keyword">break</span>;
                }
                graph.get(prerequisite).add(i); <span class="comment">// 선행 -> 현재</span>
                inDegree[i]++;
            }
        }

        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();
        <span class="keyword">for</span> (<span class="type">int</span> i = 1; i &lt;= N; i++) {
            <span class="keyword">if</span> (inDegree[i] == 0) {
                queue.add(i);
            }
        }

        <span class="keyword">while</span> (!queue.isEmpty()) {
            <span class="type">int</span> currentNode = queue.poll();

            <span class="keyword">for</span> (<span class="type">int</span> nextNode : graph.get(currentNode)) {
                <span class="comment">// (현재까지 계산된 다음 건물 시간) vs (현재 건물 완료시간 + 다음 건물 고유시간)</span>
                resultTime[nextNode] = Math.max(resultTime[nextNode], resultTime[currentNode] + time[nextNode]);
                
                inDegree[nextNode]--;
                <span class="keyword">if</span> (inDegree[nextNode] == 0) {
                    queue.add(nextNode);
                }
            }
        }

        StringBuilder sb = <span class="keyword">new</span> StringBuilder();
        <span class="keyword">for</span> (<span class="type">int</span> i = 1; i &lt;= N; i++) {
            sb.append(resultTime[i]).append(<span class="string">'\n'</span>);
        }
        System.out.print(sb.toString());
    }
}
</code></pre>
                </div>
                <div id="js-1516" class="tab-content code-javascript">
<pre><code class="language-javascript">
<span class="comment">// 1516: 게임 개발하기</span>
<span class="keyword">const</span> fs = <span class="keyword">require</span>(<span class="string">'fs'</span>);
<span class="keyword">const</span> input = fs.readFileSync(<span class="string">'/dev/stdin'</span>).toString().trim().split(<span class="string">'\n'</span>);

<span class="keyword">const</span> N = +input[0];
<span class="keyword">const</span> graph = <span class="keyword">new</span> Array(N + 1).fill(0).map(() => []);
<span class="keyword">const</span> inDegree = <span class="keyword">new</span> Array(N + 1).fill(0);
<span class="keyword">const</span> time = <span class="keyword">new</span> Array(N + 1).fill(0);
<span class="keyword">const</span> resultTime = <span class="keyword">new</span> Array(N + 1).fill(0);

<span class="keyword">for</span> (<span class="keyword">let</span> i = 1; i &lt;= N; i++) {
    <span class="keyword">const</span> line = input[i].split(<span class="string">' '</span>).map(Number);
    time[i] = line[0];
    resultTime[i] = line[0]; <span class="comment">// 초기화</span>

    <span class="keyword">for</span> (<span class="keyword">let</span> j = 1; j < line.length - 1; j++) {
        <span class="keyword">const</span> prerequisite = line[j];
        graph[prerequisite].push(i);
        inDegree[i]++;
    }
}

<span class="keyword">const</span> queue = [];
<span class="keyword">for</span> (<span class="keyword">let</span> i = 1; i &lt;= N; i++) {
    <span class="keyword">if</span> (inDegree[i] === 0) {
        queue.push(i);
    }
}

<span class="keyword">let</span> head = 0;
<span class="keyword">while</span> (head < queue.length) {
    <span class="keyword">const</span> currentNode = queue[head++];

    <span class="keyword">for</span> (<span class="keyword">const</span> nextNode <span class="keyword">of</span> graph[currentNode]) {
        resultTime[nextNode] = Math.max(
            resultTime[nextNode],
            resultTime[currentNode] + time[nextNode]
        );
        
        inDegree[nextNode]--;
        <span class="keyword">if</span> (inDegree[nextNode] === 0) {
            queue.push(nextNode);
        }
    }
}

<span class="keyword">const</span> results = [];
<span class="keyword">for</span> (<span class="keyword">let</span> i = 1; i &lt;= N; i++) {
    results.push(resultTime[i]);
}
console.log(results.join(<span class="string">'\n'</span>));
</code></pre>
                </div>
            </div>
        </div>

        <!-- 문제 6: 1753 최단 경로 구하기 -->
        <div class="problem-section">
            <h2>6. 백준 1753번: 최단 경로 구하기 (골드 V)</h2>
            <h3>문제 해석</h3>
            <p>
                방향 그래프가 주어지고, 시작 정점 K가 주어집니다. 이 시작 정점 K에서부터 다른 모든 정점까지의 최단 경로 값을 구하는 문제입니다. 경로가 존재하지 않으면 "INF"를 출력합니다.
                <br>
                이 문제는 가중치가 있는 그래프에서의 최단 경로를 구하는 문제이므로, **다익스트라(Dijkstra) 알고리즘**을 사용해야 합니다.
                <br>
                1. 모든 정점까지의 거리를 '무한대(INF)'로 초기화하고, 시작 정점 K의 거리는 0으로 설정합니다.
                <br>
                2. '최소 힙(Min Heap)'을 우선순위 큐로 사용하여, `(거리, 정점)` 쌍을 관리합니다. 시작점 `(0, K)`를 힙에 넣습니다.
                <br>
                3. 힙에서 거리가 가장 짧은 정점을 꺼냅니다. (이 정점의 최단 거리는 확정됩니다.)
                <br>
                4. 꺼낸 정점과 인접한 다른 정점들을 확인하며, 기존에 알려진 거리보다 더 짧은 경로를 발견하면(즉, `현재 정점까지의 거리 + 간선 가중치 < 인접 정점의 거리`) 거리를 갱신하고, 해당 `(갱신된 거리, 인접 정점)`을 힙에 넣습니다.
                <br>
                5. 힙이 빌 때까지 이 과정을 반복합니다.
            </p>
            <h3>코드</h3>
            <div class="tab-container">
                <div class="tab-buttons">
                    <button class="tab-button" onclick="showTab(event, 'py-1753')">Python</button>
                    <button class="tab-button" onclick="showTab(event, 'java-1753')">Java</button>
                    <button class="tab-button" onclick="showTab(event, 'js-1753')">JavaScript</button>
                </div>

                <div id="py-1753" class="tab-content code-python">
<pre><code class="language-python">
<span class="comment"># 1753: 최단 경로 구하기</span>
<span class="keyword">import</span> sys
<span class="keyword">import</span> heapq <span class="comment"># 최소 힙(우선순위 큐)</span>
input = sys.stdin.readline
INF = sys.maxsize <span class="comment"># 무한대 값</span>

V, E = map(int, input().split())
K = int(input()) <span class="comment"># 시작 정점</span>
graph = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(V + 1)]
<span class="comment"># 최단 거리 테이블</span>
distance = [INF] * (V + 1)

<span class="comment"># 간선 정보 입력</span>
<span class="keyword">for</span> _ <span class="keyword">in</span> range(E):
    u, v, w = map(int, input().split())
    graph[u].append((v, w)) <span class="comment"># (도착지, 가중치)</span>

<span class="keyword">def</span> dijkstra(start):
    pq = [] <span class="comment"># 우선순위 큐</span>
    <span class="comment"># (거리, 노드) 순서로 힙에 저장 (거리가 우선순위 기준)</span>
    heapq.heappush(pq, (0, start))
    distance[start] = 0

    <span class="keyword">while</span> pq:
        <span class="comment"># 거리가 가장 짧은 노드 정보 꺼내기</span>
        dist, current_node = heapq.heappop(pq)

        <span class="comment"># 이미 처리된 노드(더 짧은 경로를 찾은 경우)는 무시</span>
        <span class="keyword">if</span> distance[current_node] < dist:
            <span class="keyword">continue</span>

        <span class="comment"># 현재 노드와 연결된 인접 노드 확인</span>
        <span class="keyword">for</span> next_info <span class="keyword">in</span> graph[current_node]:
            next_node, weight = next_info
            new_dist = dist + weight
            
            <span class="comment"># 기존 경로보다 더 짧은 경우</span>
            <span class="keyword">if</span> new_dist < distance[next_node]:
                distance[next_node] = new_dist
                heapq.heappush(pq, (new_dist, next_node))

<span class="comment"># 다익스트라 알고리즘 수행</span>
dijkstra(K)

<span class="comment"># 결과 출력</span>
<span class="keyword">for</span> i <span class="keyword">in</span> range(1, V + 1):
    <span class="keyword">if</span> distance[i] == INF:
        print(<span class="string">"INF"</span>)
    <span class="keyword">else</span>:
        print(distance[i])
</code></pre>
                </div>
                <div id="java-1753" class="tab-content code-java">
<pre><code class="language-java">
<span class="comment">// 1753: 최단 경로 구하기</span>
<span class="keyword">import</span> java.io.BufferedReader;
<span class="keyword">import</span> java.io.InputStreamReader;
<span class="keyword">import</span> java.io.IOException;
<span class="keyword">import</span> java.util.ArrayList;
<span class="keyword">import</span> java.util.PriorityQueue;
<span class="keyword">import</span> java.util.StringTokenizer;
<span class="keyword">import</span> java.util.Arrays;

<span class="comment">// (노드, 가중치) 쌍을 저장할 클래스, 우선순위 큐에서 정렬 기준이 됨</span>
<span class="type">class</span> Node <span class="keyword">implements</span> Comparable&lt;Node&gt; {
    <span class="type">int</span> index;
    <span class="type">int</span> cost;

    Node(<span class="type">int</span> index, <span class="type">int</span> cost) {
        <span class="keyword">this</span>.index = index;
        <span class="keyword">this</span>.cost = cost;
    }

    <span class="keyword">@Override</span>
    <span class="keyword">public</span> <span class="type">int</span> compareTo(Node o) {
        <span class="keyword">return</span> Integer.compare(<span class="keyword">this</span>.cost, o.cost);
    }
}

<span class="keyword">public</span> <span class="type">class</span> Main {
    <span class="type">static</span> <span class="type">final</span> <span class="type">int</span> INF = Integer.MAX_VALUE;
    <span class="type">static</span> ArrayList&lt;ArrayList&lt;Node&gt;&gt; graph;
    <span class="type">static</span> <span class="type">int</span>[] distance;

    <span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> main(<span class="type">String</span>[] args) <span class="keyword">throws</span> IOException {
        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));
        StringTokenizer st = <span class="keyword">new</span> StringTokenizer(br.readLine());
        <span class="type">int</span> V = Integer.parseInt(st.nextToken());
        <span class="type">int</span> E = Integer.parseInt(st.nextToken());
        <span class="type">int</span> K = Integer.parseInt(br.readLine());

        graph = <span class="keyword">new</span> ArrayList&lt;&gt;();
        <span class="keyword">for</span> (<span class="type">int</span> i = 0; i &lt;= V; i++) {
            graph.add(<span class="keyword">new</span> ArrayList&lt;Node&gt;());
        }
        distance = <span class="keyword">new</span> <span class="type">int</span>[V + 1];
        Arrays.fill(distance, INF);

        <span class="keyword">for</span> (<span class="type">int</span> i = 0; i < E; i++) {
            st = <span class="keyword">new</span> StringTokenizer(br.readLine());
            <span class="type">int</span> u = Integer.parseInt(st.nextToken());
            <span class="type">int</span> v = Integer.parseInt(st.nextToken());
            <span class="type">int</span> w = Integer.parseInt(st.nextToken());
            graph.get(u).add(<span class="keyword">new</span> Node(v, w));
        }

        dijkstra(K);

        StringBuilder sb = <span class="keyword">new</span> StringBuilder();
        <span class="keyword">for</span> (<span class="type">int</span> i = 1; i &lt;= V; i++) {
            <span class="keyword">if</span> (distance[i] == INF) {
                sb.append(<span class="string">"INF"</span>).append(<span class="string">'\n'</span>);
            } <span class="keyword">else</span> {
                sb.append(distance[i]).append(<span class="string">'\n'</span>);
            }
        }
        System.out.print(sb.toString());
    }

    <span class="type">static</span> <span class="type">void</span> dijkstra(<span class="type">int</span> start) {
        PriorityQueue&lt;Node&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;();
        pq.add(<span class="keyword">new</span> Node(start, 0));
        distance[start] = 0;

        <span class="keyword">while</span> (!pq.isEmpty()) {
            Node currentNode = pq.poll();
            <span class="type">int</span> dist = currentNode.cost;
            <span class="type">int</span> nodeIndex = currentNode.index;

            <span class="keyword">if</span> (distance[nodeIndex] < dist) {
                <span class="keyword">continue</span>;
            }

            <span class="keyword">for</span> (Node nextNode : graph.get(nodeIndex)) {
                <span class="type">int</span> newDist = dist + nextNode.cost;
                <span class="keyword">if</span> (newDist < distance[nextNode.index]) {
                    distance[nextNode.index] = newDist;
                    pq.add(<span class="keyword">new</span> Node(nextNode.index, newDist));
                }
            }
        }
    }
}
</code></pre>
                </div>
                <div id="js-1753" class="tab-content code-javascript">
<pre><code class="language-javascript">
<span class="comment">// 1753: 최단 경로 구하기</span>
<span class="comment">// JavaScript에는 표준 우선순위 큐가 없으므로, 간단한 최소 힙 구현 필요</span>
<span class="comment">// (또는 배열을 매번 정렬하여 사용 - 비효율적이지만 구현은 간단)</span>
<span class="comment">// 여기서는 효율적인 최소 힙(MinHeap)을 구현하여 사용합니다.</span>

<span class="type">class</span> MinHeap {
    <span class="keyword">constructor</span>() {
        <span class="comment">// 힙 배열. 0번 인덱스는 편의상 비워둠</span>
        <span class="keyword">this</span>.heap = [null];
    }
    
    push(value) { <span class="comment">// value: [cost, node]</span>
        <span class="keyword">this</span>.heap.push(value);
        <span class="keyword">let</span> currentIndex = <span class="keyword">this</span>.heap.length - 1;
        <span class="keyword">let</span> parentIndex = Math.floor(currentIndex / 2);

        <span class="comment">// 힙 속성 유지 (부모 노드의 cost가 항상 작도록)</span>
        <span class="keyword">while</span> (parentIndex !== 0 && <span class="keyword">this</span>.heap[parentIndex][0] > <span class="keyword">this</span>.heap[currentIndex][0]) {
            [<span class="keyword">this</span>.heap[parentIndex], <span class="keyword">this</span>.heap[currentIndex]] = [<span class="keyword">this</span>.heap[currentIndex], <span class="keyword">this</span>.heap[parentIndex]];
            currentIndex = parentIndex;
            parentIndex = Math.floor(currentIndex / 2);
        }
    }

    pop() {
        <span class="keyword">if</span> (<span class="keyword">this</span>.heap.length === 1) <span class="keyword">return</span> null; <span class="comment">// 힙이 비었음</span>
        <span class="keyword">if</span> (<span class="keyword">this</span>.heap.length === 2) <span class="keyword">return</span> <span class="keyword">this</span>.heap.pop();

        <span class="keyword">const</span> minValue = <span class="keyword">this</span>.heap[1];
        <span class="keyword">this</span>.heap[1] = <span class="keyword">this</span>.heap.pop(); <span class="comment">// 마지막 원소를 루트로</span>
        <span class="keyword">let</span> currentIndex = 1;
        <span class="keyword">let</span> leftIndex = 2;
        <span class="keyword">let</span> rightIndex = 3;

        <span class="keyword">while</span> (
            (<span class="keyword">this</span>.heap[leftIndex] && <span class="keyword">this</span>.heap[currentIndex][0] > <span class="keyword">this</span>.heap[leftIndex][0]) ||
            (<span class="keyword">this</span>.heap[rightIndex] && <span class="keyword">this</span>.heap[currentIndex][0] > <span class="keyword">this</span>.heap[rightIndex][0])
        ) {
            <span class="keyword">let</span> smallerIndex = leftIndex;
            <span class="keyword">if</span> (<span class="keyword">this</span>.heap[rightIndex] && <span class="keyword">this</span>.heap[rightIndex][0] < <span class="keyword">this</span>.heap[smallerIndex][0]) {
                smallerIndex = rightIndex;
            }
            [<span class="keyword">this</span>.heap[currentIndex], <span class="keyword">this</span>.heap[smallerIndex]] = [<span class="keyword">this</span>.heap[smallerIndex], <span class="keyword">this</span>.heap[currentIndex]];
            currentIndex = smallerIndex;
            leftIndex = currentIndex * 2;
            rightIndex = currentIndex * 2 + 1;
        }
        <span class="keyword">return</span> minValue;
    }
    isEmpty() {
        <span class="keyword">return</span> <span class="keyword">this</span>.heap.length === 1;
    }
}

<span class="keyword">const</span> fs = <span class="keyword">require</span>(<span class="string">'fs'</span>);
<span class="keyword">const</span> input = fs.readFileSync(<span class="string">'/dev/stdin'</span>).toString().trim().split(<span class="string">'\n'</span>);
<span class="keyword">const</span> [V, E] = input[0].split(<span class="string">' '</span>).map(Number);
<span class="keyword">const</span> K = +input[1];
<span class="keyword">const</span> graph = <span class="keyword">new</span> Array(V + 1).fill(0).map(() => []);

<span class="keyword">for</span> (<span class="keyword">let</span> i = 2; i < E + 2; i++) {
    <span class="keyword">const</span> [u, v, w] = input[i].split(<span class="string">' '</span>).map(Number);
    graph[u].push([v, w]); <span class="comment">// [도착지, 가중치]</span>
}

<span class="keyword">const</span> distance = <span class="keyword">new</span> Array(V + 1).fill(Infinity);

<span class="keyword">function</span> dijkstra(start) {
    <span class="keyword">const</span> pq = <span class="keyword">new</span> MinHeap();
    pq.push([0, start]); <span class="comment">// [거리, 노드]</span>
    distance[start] = 0;

    <span class="keyword">while</span> (!pq.isEmpty()) {
        <span class="keyword">const</span> [dist, currentNode] = pq.pop();

        <span class="keyword">if</span> (distance[currentNode] < dist) {
            <span class="keyword">continue</span>;
        }

        <span class="keyword">for</span> (<span class="keyword">const</span> [nextNode, weight] <span class="keyword">of</span> graph[currentNode]) {
            <span class="keyword">const</span> newDist = dist + weight;
            <span class="keyword">if</span> (newDist < distance[nextNode]) {
                distance[nextNode] = newDist;
                pq.push([newDist, nextNode]);
            }
        }
    }
}

dijkstra(K);

<span class="keyword">const</span> results = [];
<span class="keyword">for</span> (<span class="keyword">let</span> i = 1; i &lt;= V; i++) {
    <span class="keyword">if</span> (distance[i] === Infinity) {
        results.push(<span class="string">"INF"</span>);
    } <span class="keyword">else</span> {
        results.push(distance[i]);
    }
}
console.log(results.join(<span class="string">'\n'</span>));
</code></pre>
                </div>
            </div>
        </div>
        
        <!-- 문제 7: 1854 K번째 최단 경로 찾기 -->
        <div class="problem-section">
            <h2>7. 백준 1854번: K번째 최단 경로 찾기 (플래티넘)</h2>
            <h3>문제 해석</h3>
            <p>
                1번 도시에서 $N$번 도시로 가는 경로 중, '최단 경로'가 아닌 **'K번째' 최단 경로**를 찾는 문제입니다. 1번 도시에서 $i$번 도시까지의 K번째 최단 경로를 각각 출력해야 합니다. 만약 K번째 최단 경로가 존재하지 않으면 -1을 출력합니다.
                <br>
                이 문제는 일반적인 다익스트라 알고리즘을 응용하여 해결할 수 있습니다.
                <br>
                1. 일반 다익스트라가 각 노드까지의 '최단 거리 1개'만 저장하는 것과 달리, 이 문제는 각 노드까지의 **'K개의 최단 경로'**를 저장해야 합니다.
                <br>
                2. 각 노드마다 K개의 거리를 저장하기 위해, **'최대 힙(Max Heap)'**을 사용합니다. 이 최대 힙은 크기를 K로 유지하며, K개의 경로 중 가장 '큰' 값(즉, K번째로 작은 값)이 루트에 오도록 합니다.
                <br>
                3. 다익스트라 알고리즘을 수행하면서 새로운 경로 `new_dist`를 발견했을 때:
                <br>
                &nbsp; a. 해당 노드의 최대 힙 크기가 K보다 작으면, 그냥 `new_dist`를 힙에 추가합니다.
                <br>
                &nbsp; b. 힙 크기가 K일 때, `new_dist`가 힙의 루트 값(현재까지의 K번째 최단 경로)보다 작다면, 루트 값을 제거하고 `new_dist`를 힙에 추가합니다.
                <br>
                4. 이 두 경우(a, b)에 모두 새로운 경로가 추가되었으므로, `(new_dist, next_node)`를 다익스트라의 메인 우선순위 큐(최소 힙)에 넣어 탐색을 계속합니다.
                <br>
                5. 알고리즘 종료 후, 각 노드의 최대 힙 크기가 K이면 루트 값을 출력하고, K보다 작으면 -1을 출력합니다.
            </p>
            <h3>코드</h3>
            <div class="tab-container">
                <div class="tab-buttons">
                    <button class="tab-button" onclick="showTab(event, 'py-1854')">Python</button>
                    <button class="tab-button" onclick="showTab(event, 'java-1854')">Java</button>
                    <button class="tab-button" onclick="showTab(event, 'js-1854')">JavaScript</button>
                </div>

                <div id="py-1854" class="tab-content code-python">
<pre><code class="language-python">
<span class="comment"># 1854: K번째 최단 경로 찾기 (사용자 제공 코드)</span>
<span class="keyword">import</span> sys
<span class="keyword">import</span> heapq

input = sys.stdin.readline
INF = sys.maxsize

n, m, k = map(int, input().split())
graph = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n + 1)]
<span class="comment"># 각 노드별로 k개의 최단 경로를 저장할 리스트 (최대 힙으로 사용)</span>
distance = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n + 1)]

<span class="keyword">for</span> _ <span class="keyword">in</span> range(m):
    u, v, weight = map(int, input().split())
    graph[u].append((v, weight))

<span class="keyword">def</span> dijkstra_kth(start):
    pq = [] <span class="comment"># 다익스트라를 위한 최소 힙 (거리, 노드)</span>
    heapq.heappush(pq, (0, start))
    
    <span class="comment"># 시작 노드의 1번째 최단 경로는 0 (최대 힙 구현을 위해 음수로 저장)</span>
    heapq.heappush(distance[start], 0)

    <span class="keyword">while</span> pq:
        dist, current_node = heapq.heappop(pq)

        <span class="keyword">for</span> next_node, weight <span class="keyword">in</span> graph[current_node]:
            new_dist = dist + weight
            
            <span class="comment"># 해당 노드의 최단 경로 리스트가 k개 미만이면</span>
            <span class="keyword">if</span> len(distance[next_node]) < k:
                <span class="comment"># 최대 힙에 음수로 저장</span>
                heapq.heappush(distance[next_node], -new_dist)
                <span class="comment"># 다음 탐색을 위해 다익스트라 큐(최소 힙)에 양수로 저장</span>
                heapq.heappush(pq, (new_dist, next_node))
            
            <span class="comment"># k개가 찼지만, 새 경로가 k번째 경로(최대 힙의 루트)보다 짧다면</span>
            <span class="comment"># (distance[next_node][0]이 음수이므로 -를 붙여 비교)</span>
            <span class="keyword">elif</span> new_dist < -distance[next_node][0]:
                <span class="comment"># k번째 경로를 빼고 새 경로를 넣음 (heapreplace 사용)</span>
                heapq.heapreplace(distance[next_node], -new_dist)
                heapq.heappush(pq, (new_dist, next_node))

dijkstra_kth(1)

<span class="comment"># 결과 출력</span>
<span class="keyword">for</span> i <span class="keyword">in</span> range(1, n + 1):
    <span class="comment"># k개의 경로가 채워지지 않았다면 -1</span>
    <span class="keyword">if</span> len(distance[i]) < k:
        print(-1)
    <span class="keyword">else</span>:
        <span class="comment"># k번째 경로는 최대 힙의 루트(첫번째 값)이므로 -를 붙여 출력</span>
        print(-distance[i][0])
</code></pre>
                </div>
                <div id="java-1854" class="tab-content code-java">
<pre><code class="language-java">
<span class="comment">// 1854: K번째 최단 경로 찾기</span>
<span class="keyword">import</span> java.io.BufferedReader;
<span class="keyword">import</span> java.io.InputStreamReader;
<span class="keyword">import</span> java.io.IOException;
<span class="keyword">import</span> java.util.ArrayList;
<span class="keyword">import</span> java.util.PriorityQueue;
<span class="keyword">import</span> java.util.StringTokenizer;
<span class="keyword">import</span> java.util.Collections;

<span class="comment">// 다익스트라를 위한 노드 (최소 힙용)</span>
<span class="type">class</span> Node <span class="keyword">implements</span> Comparable&lt;Node&gt; {
    <span class="type">int</span> index;
    <span class="type">int</span> cost;

    Node(<span class="type">int</span> index, <span class="type">int</span> cost) {
        <span class="keyword">this</span>.index = index;
        <span class="keyword">this</span>.cost = cost;
    }

    <span class="keyword">@Override</span>
    <span class="keyword">public</span> <span class="type">int</span> compareTo(Node o) {
        <span class="keyword">return</span> Integer.compare(<span class="keyword">this</span>.cost, o.cost);
    }
}

<span class="keyword">public</span> <span class="type">class</span> Main {
    <span class="type">static</span> ArrayList&lt;ArrayList&lt;Node&gt;&gt; graph;
    <span class="comment">// 각 노드별 K개의 최단 경로를 저장할 최대 힙 배열</span>
    <span class="type">static</span> PriorityQueue&lt;Integer&gt;[] distHeap; 
    <span class="type">static</span> <span class="type">int</span> n, m, k;

    <span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> main(<span class="type">String</span>[] args) <span class="keyword">throws</span> IOException {
        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));
        StringTokenizer st = <span class="keyword">new</span> StringTokenizer(br.readLine());
        n = Integer.parseInt(st.nextToken());
        m = Integer.parseInt(st.nextToken());
        k = Integer.parseInt(st.nextToken());

        graph = <span class="keyword">new</span> ArrayList&lt;&gt;();
        distHeap = <span class="keyword">new</span> PriorityQueue[n + 1];

        <span class="keyword">for</span> (<span class="type">int</span> i = 0; i &lt;= n; i++) {
            graph.add(<span class="keyword">new</span> ArrayList&lt;Node&gt;());
            <span class="comment">// 최대 힙 (내림차순 정렬)</span>
            distHeap[i] = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;(Collections.reverseOrder());
        }

        <span class="keyword">for</span> (<span class="type">int</span> i = 0; i < m; i++) {
            st = <span class="keyword">new</span> StringTokenizer(br.readLine());
            <span class="type">int</span> u = Integer.parseInt(st.nextToken());
            <span class="type">int</span> v = Integer.parseInt(st.nextToken());
            <span class="type">int</span> w = Integer.parseInt(st.nextToken());
            graph.get(u).add(<span class="keyword">new</span> Node(v, w));
        }

        dijkstra(1);

        StringBuilder sb = <span class="keyword">new</span> StringBuilder();
        <span class="keyword">for</span> (<span class="type">int</span> i = 1; i &lt;= n; i++) {
            <span class="keyword">if</span> (distHeap[i].size() == k) {
                sb.append(distHeap[i].peek()).append(<span class="string">'\n'</span>);
            } <span class="keyword">else</span> {
                sb.append(-1).append(<span class="string">'\n'</span>);
            }
        }
        System.out.print(sb.toString());
    }

    <span class="type">static</span> <span class="type">void</span> dijkstra(<span class="type">int</span> start) {
        <span class="comment">// 다익스트라용 최소 힙</span>
        PriorityQueue&lt;Node&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;();
        pq.add(<span class="keyword">new</span> Node(start, 0));
        distHeap[start].add(0); <span class="comment">// 1번 노드의 1번째 최단경로는 0</span>

        <span class="keyword">while</span> (!pq.isEmpty()) {
            Node currentNode = pq.poll();
            <span class="type">int</span> dist = currentNode.cost;
            <span class="type">int</span> nodeIndex = currentNode.index;

            <span class="keyword">for</span> (Node nextNode : graph.get(nodeIndex)) {
                <span class="type">int</span> newDist = dist + nextNode.cost;
                <span class="type">int</span> nextNodeIndex = nextNode.index;

                <span class="comment">// K개 미만이면 그냥 추가</span>
                <span class="keyword">if</span> (distHeap[nextNodeIndex].size() < k) {
                    distHeap[nextNodeIndex].add(newDist);
                    pq.add(<span class="keyword">new</span> Node(nextNodeIndex, newDist));
                } 
                <span class="comment">// K개가 찼고, 새 경로가 K번째(최대 힙 루트)보다 작으면 교체</span>
                <span class="keyword">else</span> <span class="keyword">if</span> (newDist < distHeap[nextNodeIndex].peek()) {
                    distHeap[nextNodeIndex].poll(); <span class="comment">// K번째(가장 큰 값) 제거</span>
                    distHeap[nextNodeIndex].add(newDist); <span class="comment">// 새 경로 추가</span>
                    pq.add(<span class="keyword">new</span> Node(nextNodeIndex, newDist));
                }
            }
        }
    }
}
</code></pre>
                </div>
                <div id="js-1854" class="tab-content code-javascript">
<pre><code class="language-javascript">
<span class="comment">// 1854: K번째 최단 경로 찾기</span>
<span class="comment">// JavaScript로 플래티넘 난이도, 특히 힙을 2중으로 쓰는 문제는</span>
<span class="comment">// 시간 초과(TLE) 위험이 매우 큽니다. (MinHeap, MaxHeap 구현 필요)</span>
<span class="comment">// 여기서는 MinHeap 클래스(1753번 참조)와 MaxHeap 클래스를 모두 사용합니다.</span>

<span class="comment">// (MinHeap 클래스 구현 - 1753번 코드와 동일)</span>
<span class="type">class</span> MinHeap {
    <span class="keyword">constructor</span>() { <span class="keyword">this</span>.heap = [null]; }
    push(value) { <span class="comment">// value: [cost, node]</span>
        <span class="keyword">this</span>.heap.push(value);
        <span class="keyword">let</span> currentIndex = <span class="keyword">this</span>.heap.length - 1;
        <span class="keyword">let</span> parentIndex = Math.floor(currentIndex / 2);
        <span class="keyword">while</span> (parentIndex !== 0 && <span class="keyword">this</span>.heap[parentIndex][0] > <span class="keyword">this</span>.heap[currentIndex][0]) {
            [<span class="keyword">this</span>.heap[parentIndex], <span class="keyword">this</span>.heap[currentIndex]] = [<span class="keyword">this</span>.heap[currentIndex], <span class="keyword">this</span>.heap[parentIndex]];
            currentIndex = parentIndex;
            parentIndex = Math.floor(currentIndex / 2);
        }
    }
    pop() {
        <span class="keyword">if</span> (<span class="keyword">this</span>.heap.length === 1) <span class="keyword">return</span> null;
        <span class="keyword">if</span> (<span class="keyword">this</span>.heap.length === 2) <span class="keyword">return</span> <span class="keyword">this</span>.heap.pop();
        <span class="keyword">const</span> minValue = <span class="keyword">this</span>.heap[1];
        <span class="keyword">this</span>.heap[1] = <span class="keyword">this</span>.heap.pop();
        <span class="keyword">let</span> currentIndex = 1, leftIndex = 2, rightIndex = 3;
        <span class="keyword">while</span> (
            (<span class="keyword">this</span>.heap[leftIndex] && <span class="keyword">this</span>.heap[currentIndex][0] > <span class="keyword">this</span>.heap[leftIndex][0]) ||
            (<span class="keyword">this</span>.heap[rightIndex] && <span class="keyword">this</span>.heap[currentIndex][0] > <span class="keyword">this</span>.heap[rightIndex][0])
        ) {
            <span class="keyword">let</span> smallerIndex = leftIndex;
            <span class="keyword">if</span> (<span class="keyword">this</span>.heap[rightIndex] && <span class="keyword">this</span>.heap[rightIndex][0] < <span class="keyword">this</span>.heap[smallerIndex][0]) {
                smallerIndex = rightIndex;
            }
            [<span class="keyword">this</span>.heap[currentIndex], <span class="keyword">this</span>.heap[smallerIndex]] = [<span class="keyword">this</span>.heap[smallerIndex], <span class="keyword">this</span>.heap[currentIndex]];
            currentIndex = smallerIndex;
            leftIndex = currentIndex * 2;
            rightIndex = currentIndex * 2 + 1;
        }
        <span class="keyword">return</span> minValue;
    }
    isEmpty() { <span class="keyword">return</span> <span class="keyword">this</span>.heap.length === 1; }
}

<span class="comment">// K번째 경로 저장을 위한 MaxHeap (MinHeap과 부등호만 반대)</span>
<span class="type">class</span> MaxHeap {
    <span class="keyword">constructor</span>() { <span class="keyword">this</span>.heap = [null]; }
    push(value) {
        <span class="keyword">this</span>.heap.push(value);
        <span class="keyword">let</span> ci = <span class="keyword">this</span>.heap.length - 1;
        <span class="keyword">let</span> pi = Math.floor(ci / 2);
        <span class="keyword">while</span> (pi !== 0 && <span class="keyword">this</span>.heap[pi] < <span class="keyword">this</span>.heap[ci]) {
            [<span class="keyword">this</span>.heap[pi], <span class="keyword">this</span>.heap[ci]] = [<span class="keyword">this</span>.heap[ci], <span class="keyword">this</span>.heap[pi]];
            ci = pi;
            pi = Math.floor(ci / 2);
        }
    }
    pop() {
        <span class="keyword">if</span> (<span class="keyword">this</span>.heap.length === 1) <span class="keyword">return</span> null;
        <span class="keyword">if</span> (<span class="keyword">this</span>.heap.length === 2) <span class="keyword">return</span> <span class="keyword">this</span>.heap.pop();
        <span class="keyword">const</span> maxVal = <span class="keyword">this</span>.heap[1];
        <span class="keyword">this</span>.heap[1] = <span class="keyword">this</span>.heap.pop();
        <span class="keyword">let</span> ci = 1, li = 2, ri = 3;
        <span class="keyword">while</span> (
            (<span class="keyword">this</span>.heap[li] && <span class="keyword">this</span>.heap[ci] < <span class="keyword">this</span>.heap[li]) ||
            (<span class="keyword">this</span>.heap[ri] && <span class="keyword">this</span>.heap[ci] < <span class="keyword">this</span>.heap[ri])
        ) {
            <span class="keyword">let</span> mi = li;
            <span class="keyword">if</span> (<span class="keyword">this</span>.heap[ri] && <span class="keyword">this</span>.heap[ri] > <span class="keyword">this</span>.heap[mi]) mi = ri;
            [<span class="keyword">this</span>.heap[ci], <span class="keyword">this</span>.heap[mi]] = [<span class="keyword">this</span>.heap[mi], <span class="keyword">this</span>.heap[ci]];
            ci = mi; li = ci * 2; ri = ci * 2 + 1;
        }
        <span class="keyword">return</span> maxVal;
    }
    peek() { <span class="keyword">return</span> <span class="keyword">this</span>.heap[1] || null; }
    size() { <span class="keyword">return</span> <span class="keyword">this</span>.heap.length - 1; }
}

<span class="keyword">const</span> fs = <span class="keyword">require</span>(<span class="string">'fs'</span>);
<span class="keyword">const</span> input = fs.readFileSync(<span class="string">'/dev/stdin'</span>).toString().trim().split(<span class="string">'\n'</span>);
<span class="keyword">const</span> [n, m, k] = input[0].split(<span class="string">' '</span>).map(Number);
<span class="keyword">const</span> graph = <span class="keyword">new</span> Array(n + 1).fill(0).map(() => []);
<span class="comment">// 각 노드별 MaxHeap 배열</span>
<span class="keyword">const</span> distHeaps = <span class="keyword">new</span> Array(n + 1).fill(0).map(() => <span class="keyword">new</span> MaxHeap());

<span class="keyword">for</span> (<span class="keyword">let</span> i = 1; i &lt;= m; i++) {
    <span class="keyword">const</span> [u, v, w] = input[i].split(<span class="string">' '</span>).map(Number);
    graph[u].push([v, w]); <span class="comment">// [도착지, 가중치]</span>
}

<span class="keyword">function</span> dijkstraKth(start) {
    <span class="keyword">const</span> pq = <span class="keyword">new</span> MinHeap(); <span class="comment">// 다익스트라용 최소 힙</span>
    pq.push([0, start]); <span class="comment">// [거리, 노드]</span>
    distHeaps[start].push(0);

    <span class="keyword">while</span> (!pq.isEmpty()) {
        <span class="keyword">const</span> [dist, currentNode] = pq.pop();

        <span class="keyword">for</span> (<span class="keyword">const</span> [nextNode, weight] <span class="keyword">of</span> graph[currentNode]) {
            <span class="keyword">const</span> newDist = dist + weight;
            
            <span class="keyword">if</span> (distHeaps[nextNode].size() < k) {
                distHeaps[nextNode].push(newDist);
                pq.push([newDist, nextNode]);
            } <span class="keyword">else</span> <span class="keyword">if</span> (newDist < distHeaps[nextNode].peek()) {
                distHeaps[nextNode].pop();
                distHeaps[nextNode].push(newDist);
                pq.push([newDist, nextNode]);
            }
        }
    }
}

dijkstraKth(1);

<span class="keyword">const</span> results = [];
<span class="keyword">for</span> (<span class="keyword">let</span> i = 1; i &lt;= n; i++) {
    <span class="keyword">if</span> (distHeaps[i].size() === k) {
        results.push(distHeaps[i].peek());
    } <span class="keyword">else</span> {
        results.push(-1);
    }
}
console.log(results.join(<span class="string">'\n'</span>));
</code></pre>
                </div>
            </div>
        </div>

    </div>

    <script>
        // 초기 탭 설정 (각 문제의 Python 탭을 기본으로 활성화)
        document.addEventListener('DOMContentLoaded', function() {
            const problemSections = document.querySelectorAll('.problem-section');
            problemSections.forEach(section => {
                const firstButton = section.querySelector('.tab-button');
                if (firstButton) {
                    const firstContentId = firstButton.getAttribute('onclick').split("'")[1];
                    firstButton.classList.add('active');
                    section.querySelector('#' + firstContentId).classList.add('active');
                }
            });
        });

        function showTab(event, tabId) {
            const button = event.currentTarget;
            const tabContainer = button.closest('.tab-container'); // 현재 탭 컨테이너 찾기
            
            // 현재 탭 컨테이너 내의 모든 탭 버튼 비활성화
            const tabButtons = tabContainer.querySelectorAll('.tab-button');
            tabButtons.forEach(btn => btn.classList.remove('active'));

            // 현재 탭 컨테이너 내의 모든 탭 콘텐츠 숨기기
            const tabContents = tabContainer.querySelectorAll('.tab-content');
            tabContents.forEach(content => content.classList.remove('active'));

            // 클릭한 탭 버튼과 콘텐츠 활성화
            button.classList.add('active');
            tabContainer.querySelector('#' + tabId).classList.add('active');
        }
    </script>

</body>
</html>
